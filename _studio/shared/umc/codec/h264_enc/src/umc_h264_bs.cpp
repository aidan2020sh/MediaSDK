// Copyright (c) 2004-2019 Intel Corporation
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "umc_defs.h"
#if defined(MFX_ENABLE_H264_VIDEO_ENCODE)

#include <string.h>
#include "umc_h264_bs.h"
#include "umc_h264_video_encoder.h"
#include "umc_h264_core_enc.h"
#include "umc_h264_tables.h"

// Bit stream field sizes
namespace UMC_H264_ENCODER
{

typedef struct {
    Ipp8u code;
    Ipp8u len;
} struct_CodeEntry;


/* Table G-10 */
static Ipp8u H264TotalCoeffTrailingOnesTab0[] = {
    0,  5, 10, 15,  4,  9, 19, 14, 23,  8, 13, 18, 27, 12, 17, 22,
    31, 16, 21, 26, 35, 20, 25, 30, 39, 24, 29, 34, 43, 28, 33, 38,
    32, 36, 37, 42, 47, 40, 41, 46, 51, 44, 45, 50, 55, 48, 49, 54,
    59, 53, 52, 57, 58, 63, 56, 61, 62, 67, 60, 65, 66, 64
};

static Ipp8u H264TotalCoeffTrailingOnesTab1[] = {
    0,  5, 10, 15, 19,  9, 23,  4, 13, 14, 27,  8, 17, 18, 31, 12,
    21, 22, 35, 16, 25, 26, 20, 24, 29, 30, 39, 28, 33, 34, 43, 32,
    37, 38, 47, 36, 41, 42, 51, 40, 45, 46, 44, 48, 49, 50, 55, 52,
    53, 54, 59, 56, 58, 63, 57, 60, 61, 62, 67, 64, 65, 66
};

static Ipp8u H264TotalCoeffTrailingOnesTab2[] = {
    0,  5, 10, 15, 19, 23, 27, 31,  9, 14, 35, 13, 18, 17, 22, 21,
    4, 25, 26, 39,  8, 29, 30, 12, 16, 33, 34, 43, 20, 38, 24, 28,
    32, 37, 42, 47, 36, 41, 46, 51, 40, 45, 50, 55, 44, 49, 54, 48,
    53, 52, 57, 58, 59, 56, 61, 62, 63, 60, 65, 66, 67, 64
};

static Ipp8u H264CoeffTokenIdxTab0[] = {
    0,  0,  0,  0,  4,  1,  0,  0,  9,  5,  2,  0, 13, 10,  7,  3,
    17, 14, 11,  6, 21, 18, 15,  8, 25, 22, 19, 12, 29, 26, 23, 16,
    32, 30, 27, 20, 33, 34, 31, 24, 37, 38, 35, 28, 41, 42, 39, 36,
    45, 46, 43, 40, 50, 49, 47, 44, 54, 51, 52, 48, 58, 55, 56, 53,
    61, 59, 60, 57
};

static Ipp8u H264CoeffTokenIdxTab1[] = {
    0,  0,  0,  0,  7,  1,  0,  0, 11,  5,  2,  0, 15,  8,  9,  3,
    19, 12, 13,  4, 22, 16, 17,  6, 23, 20, 21, 10, 27, 24, 25, 14,
    31, 28, 29, 18, 35, 32, 33, 26, 39, 36, 37, 30, 42, 40, 41, 34,
    43, 44, 45, 38, 47, 48, 49, 46, 51, 54, 52, 50, 55, 56, 57, 53,
    59, 60, 61, 58
};

static Ipp8u H264CoeffTokenIdxTab2[] = {
    0,  0,  0,  0, 16,  1,  0,  0, 20,  8,  2,  0, 23, 11,  9,  3,
    24, 13, 12,  4, 28, 15, 14,  5, 30, 17, 18,  6, 31, 21, 22,  7,
    32, 25, 26, 10, 36, 33, 29, 19, 40, 37, 34, 27, 44, 41, 38, 35,
    47, 45, 42, 39, 49, 48, 46, 43, 53, 50, 51, 52, 57, 54, 55, 56,
    61, 58, 59, 60
};

static Ipp8u* H264TotalCoeffTrailingOnesTab[] = {
    H264TotalCoeffTrailingOnesTab0,
    H264TotalCoeffTrailingOnesTab1,
    H264TotalCoeffTrailingOnesTab2,
    H264TotalCoeffTrailingOnesTab2,
    H264TotalCoeffTrailingOnesTab2,
    H264TotalCoeffTrailingOnesTab2
};

static Ipp8u* H264CoeffTokenIdxTab[] = {
    H264CoeffTokenIdxTab0,
    H264CoeffTokenIdxTab1,
    H264CoeffTokenIdxTab2,
    H264CoeffTokenIdxTab2,
    H264CoeffTokenIdxTab2,
    H264CoeffTokenIdxTab2
};

static const struct_CodeEntry EncTotalCoeff[5][17][4] =
{
    {   // Num-VLC0
        //   0       1       2       3  <-- Trailing Ones
        { { 1, 1},{ 0, 0},{ 0, 0},{ 0, 0} }, // 0 Total_Coeffs
        { { 5, 6},{ 1, 2},{ 0, 0},{ 0, 0} }, // 1 Total_Coeffs
        { { 7, 8},{ 4, 6},{ 1, 3},{ 0, 0} }, // 2 Total_Coeffs
        { { 7, 9},{ 6, 8},{ 5, 7},{ 3, 5} }, // 3 Total_Coeffs
        { { 7,10},{ 6, 9},{ 5, 8},{ 3, 6} }, // 4 Total_Coeffs
        { { 7,11},{ 6,10},{ 5, 9},{ 4, 7} }, // 5 Total_Coeffs
        { {15,13},{ 6,11},{ 5,10},{ 4, 8} }, // 6 Total_Coeffs
        { {11,13},{14,13},{ 5,11},{ 4, 9} }, // 7 Total_Coeffs
        { { 8,13},{10,13},{13,13},{ 4,10} }, // 8 Total_Coeffs
        { {15,14},{14,14},{ 9,13},{ 4,11} }, // 9 Total_Coeffs
        { {11,14},{10,14},{13,14},{12,13} }, // 10 Total_Coeffs
        { {15,15},{14,15},{ 9,14},{12,14} }, // 11 Total_Coeffs
        { {11,15},{10,15},{13,15},{ 8,14} }, // 12 Total_Coeffs
        { {15,16},{ 1,15},{ 9,15},{12,15} }, // 13 Total_Coeffs
        { {11,16},{14,16},{13,16},{ 8,15} }, // 14 Total_Coeffs
        { { 7,16},{10,16},{ 9,16},{12,16} }, // 15 Total_Coeffs
        { { 4,16},{ 6,16},{ 5,16},{ 8,16} }  // 16 Total_Coeffs

    },
    {   // Num-VLC1
        //   0       1       2       3  <-- Trailing Ones
        { { 3, 2},{ 0, 0},{ 0, 0},{ 0, 0} }, // 0 Total_Coeffs
        { {11, 6},{ 2, 2},{ 0, 0},{ 0, 0} }, // 1 Total_Coeffs
        { { 7, 6},{ 7, 5},{ 3, 3},{ 0, 0} }, // 2 Total_Coeffs
        { { 7, 7},{10, 6},{ 9, 6},{ 5, 4} }, // 3 Total_Coeffs
        { { 7, 8},{ 6, 6},{ 5, 6},{ 4, 4} }, // 4 Total_Coeffs
        { { 4, 8},{ 6, 7},{ 5, 7},{ 6, 5} }, // 5 Total_Coeffs
        { { 7, 9},{ 6, 8},{ 5, 8},{ 8, 6} }, // 6 Total_Coeffs
        { {15,11},{ 6, 9},{ 5, 9},{ 4, 6} }, // 7 Total_Coeffs
        { {11,11},{14,11},{13,11},{ 4, 7} }, // 8 Total_Coeffs
        { {15,12},{10,11},{ 9,11},{ 4, 9} }, // 9 Total_Coeffs
        { {11,12},{14,12},{13,12},{12,11} }, // 10 Total_Coeffs
        { { 8,12},{10,12},{ 9,12},{ 8,11} }, // 11 Total_Coeffs
        { {15,13},{14,13},{13,13},{12,12} }, // 12 Total_Coeffs
        { {11,13},{10,13},{ 9,13},{12,13} }, // 13 Total_Coeffs
        { { 7,13},{11,14},{ 6,13},{ 8,13} }, // 14 Total_Coeffs
        { { 9,14},{ 8,14},{10,14},{ 1,13} }, // 15 Total_Coeffs
        { { 7,14},{ 6,14},{ 5,14},{ 4,14} }  // 16 Total_Coeffs
    },
    {   // Num-VLC2
        //   0       1       2       3  <-- Trailing Ones
        { {15, 4},{ 0, 0},{ 0, 0},{ 0, 0} }, // 0 Total_Coeffs
        { {15, 6},{14, 4},{ 0, 0},{ 0, 0} }, // 1 Total_Coeffs
        { {11, 6},{15, 5},{13, 4},{ 0, 0} }, // 2 Total_Coeffs
        { { 8, 6},{12, 5},{14, 5},{12, 4} }, // 3 Total_Coeffs
        { {15, 7},{10, 5},{11, 5},{11, 4} }, // 4 Total_Coeffs
        { {11, 7},{ 8, 5},{ 9, 5},{10, 4} }, // 5 Total_Coeffs
        { { 9, 7},{14, 6},{13, 6},{ 9, 4} }, // 6 Total_Coeffs
        { { 8, 7},{10, 6},{ 9, 6},{ 8, 4} }, // 7 Total_Coeffs
        { {15, 8},{14, 7},{13, 7},{13, 5} }, // 8 Total_Coeffs
        { {11, 8},{14, 8},{10, 7},{12, 6} }, // 9 Total_Coeffs
        { {15, 9},{10, 8},{13, 8},{12, 7} }, // 10 Total_Coeffs
        { {11, 9},{14, 9},{ 9, 8},{12, 8} }, // 11 Total_Coeffs
        { { 8, 9},{10, 9},{13, 9},{ 8, 8} }, // 12 Total_Coeffs
        { {13,10},{ 7, 9},{ 9, 9},{12, 9} }, // 13 Total_Coeffs
        { { 9,10},{12,10},{11,10},{10,10} }, // 14 Total_Coeffs
        { { 5,10},{ 8,10},{ 7,10},{ 6,10} }, // 15 Total_Coeffs
        { { 1,10},{ 4,10},{ 3,10},{ 2,10} }  // 16 Total_Coeffs
    },
    {   // Num-VLC_ChromaDC 420
        //   0       1       2       3  <-- Trailing Ones
        { { 1, 2},{ 0, 0},{ 0, 0},{ 0, 0} }, // 0 Total_Coeffs
        { { 7, 6},{ 1, 1},{ 0, 0},{ 0, 0} }, // 1 Total_Coeffs
        { { 4, 6},{ 6, 6},{ 1, 3},{ 0, 0} }, // 2 Total_Coeffs
        { { 3, 6},{ 3, 7},{ 2, 7},{ 5, 6} }, // 3 Total_Coeffs
        { { 2, 6},{ 3, 8},{ 2, 8},{ 0, 7} }, // 4 Total_Coeffs
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} }, // Not used...
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} }
    },
    {   // Num-VLC_ChromaDC 422
        //   0       1       2       3  <-- Trailing Ones
        { { 1,  1},{ 0,  0},{ 0,  0},{ 0, 0} }, // 0 Total_Coeffs
        { { 15, 7},{ 1,  2},{ 0,  0},{ 0, 0} }, // 1 Total_Coeffs
        { { 14, 7},{ 13, 7},{ 1,  3},{ 0, 0} }, // 2 Total_Coeffs
        { {  7, 9},{ 12, 7},{ 11, 7},{ 1, 5} }, // 3 Total_Coeffs
        { {  6, 9},{ 5,  9},{ 10, 7},{ 1, 6}  }, // 4 Total_Coeffs
        { { 7, 10},{ 6, 10},{ 4,  9},{ 9, 7} }, // 5 Total_Coeffs
        { { 7, 11},{ 6, 11},{ 5, 10},{ 8, 7} }, // 6 Total_Coeffs
        { { 7, 12},{ 6, 12},{ 5, 11},{ 4, 10} }, // 7 Total_Coeffs
        { { 7, 13},{ 5, 12},{ 4, 12},{ 4, 11} }, // 8 Total_Coeffs
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} }, // Not used...
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} },
        { { 0, 0},{ 0, 0},{ 0, 0},{ 0, 0} }
    }
};

static const struct_CodeEntry EncTotalZerosChroma[3][16][16] = {
    {
    //  0     1     2    <- (TotalCoeff-1)
    { {1,1},{1,1},{1,1} },  // 0 TotalZeros
    { {1,2},{1,2},{0,1} },  // 1 TotalZeros
    { {1,3},{0,2},{0,0} },  // 2 TotalZeros
    { {0,3},{0,0},{0,0} }   // 3 TotalZeros
    },{
    //  0     1     2     3     4     5     6 <- (TotalCoeff-1)
    { {1,1},{0,3},{0,3},{6,3},{0,2},{0,2},{0,1} },   // 0 TotalZeros
    { {2,3},{1,2},{1,3},{0,2},{1,2},{1,2},{1,1} },   // 1 TotalZeros
    { {3,3},{1,3},{1,2},{1,2},{2,2},{1,1},{0,0} },   // 2 TotalZeros
    { {2,4},{4,3},{2,2},{2,2},{3,2},{0,0},{0,0} },   // 3 TotalZeros
    { {3,4},{5,3},{6,3},{7,3},{0,0},{0,0},{0,0} },   // 4 TotalZeros
    { {1,4},{6,3},{7,3},{0,0},{0,0},{0,0},{0,0} },   // 5 TotalZeros
    { {1,5},{7,3},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 6 TotalZeros
    { {0,5},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 7 TotalZeros
    },{
    //  0     1     2     3     4     5     6     7     8     9     10    11    12    13    14 <- (TotalCoeff-1)
    { {1,1},{7,3},{5,4},{3,5},{5,4},{1,6},{1,6},{1,6},{1,6},{1,5},{0,4},{0,4},{0,3},{0,2},{0,1} },   // 0 TotalZeros
    { {3,3},{6,3},{7,3},{7,3},{4,4},{1,5},{1,5},{1,4},{0,6},{0,5},{1,4},{1,4},{1,3},{1,2},{1,1} },   // 1 TotalZeros
    { {2,3},{5,3},{6,3},{5,4},{3,4},{7,3},{5,3},{1,5},{1,4},{1,3},{1,3},{1,2},{1,1},{1,1},{0,0} },   // 2 TotalZeros
    { {3,4},{4,3},{5,3},{4,4},{7,3},{6,3},{4,3},{3,3},{3,2},{3,2},{2,3},{1,1},{1,2},{0,0},{0,0} },   // 3 TotalZeros
    { {2,4},{3,3},{4,4},{6,3},{6,3},{5,3},{3,3},{3,2},{2,2},{2,2},{1,1},{1,3},{0,0},{0,0},{0,0} },   // 4 TotalZeros
    { {3,5},{5,4},{3,4},{5,3},{5,3},{4,3},{3,2},{2,2},{1,3},{1,2},{3,3},{0,0},{0,0},{0,0},{0,0} },   // 5 TotalZeros
    { {2,5},{4,4},{4,3},{4,3},{4,3},{3,3},{2,3},{2,3},{1,2},{1,4},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 6 TotalZeros
    { {3,6},{3,4},{3,3},{3,4},{3,3},{2,3},{1,4},{1,3},{1,5},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 7 TotalZeros
    { {2,6},{2,4},{2,4},{3,3},{2,4},{1,4},{1,3},{0,6},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 8 TotalZeros
    { {3,7},{3,5},{3,5},{2,4},{1,5},{1,3},{0,6},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 9 TotalZeros
    { {2,7},{2,5},{2,5},{2,5},{1,4},{0,6},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 10 TotalZeros
    { {3,8},{3,6},{1,6},{1,5},{0,5},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 11 TotalZeros
    { {2,8},{2,6},{1,5},{0,5},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 12 TotalZeros
    { {3,9},{1,6},{0,6},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 13 TotalZeros
    { {2,9},{0,6},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 14 TotalZeros
    { {1,9},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0} },   // 15 TotalZeros
    }
};

static const struct_CodeEntry EncTotalZeros4x4[16][16] = {
    //   0/7   1/8   2/9  3/10  4/11  5/12  6/13   14  <- (TotalCoeff-1)
    {   {1,1},{7,3},{5,4},{3,5},{5,4},{1,6},{1,6},
        {1,6},{1,6},{1,5},{0,4},{0,4},{0,3},{0,2},{0,1}, {0,0} },  // 0 TotalZeros
    {   {3,3},{6,3},{7,3},{7,3},{4,4},{1,5},{1,5},
        {1,4},{0,6},{0,5},{1,4},{1,4},{1,3},{1,2},{1,1}, {0,0} },  // 1 TotalZeros
    {   {2,3},{5,3},{6,3},{5,4},{3,4},{7,3},{5,3},
        {1,5},{1,4},{1,3},{1,3},{1,2},{1,1},{1,1},{0,0}, {0,0} },  // 2 TotalZeros
    {   {3,4},{4,3},{5,3},{4,4},{7,3},{6,3},{4,3},
        {3,3},{3,2},{3,2},{2,3},{1,1},{1,2},{0,0},{0,0}, {0,0} },  // 3 TotalZeros
    {   {2,4},{3,3},{4,4},{6,3},{6,3},{5,3},{3,3},
        {3,2},{2,2},{2,2},{1,1},{1,3},{0,0},{0,0},{0,0}, {0,0} },  // 4 TotalZeros
    {   {3,5},{5,4},{3,4},{5,3},{5,3},{4,3},{3,2},
        {2,2},{1,3},{1,2},{3,3},{0,0},{0,0},{0,0},{0,0}, {0,0} },  // 5 TotalZeros
    {   {2,5},{4,4},{4,3},{4,3},{4,3},{3,3},{2,3},
        {2,3},{1,2},{1,4},{0,0},{0,0},{0,0},{0,0},{0,0}, {0,0} },  // 6 TotalZeros
    {   {3,6},{3,4},{3,3},{3,4},{3,3},{2,3},{1,4},
        {1,3},{1,5},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, {0,0} },  // 7 TotalZeros
    {   {2,6},{2,4},{2,4},{3,3},{2,4},{1,4},{1,3},
        {0,6},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, {0,0} },  // 8 TotalZeros
    {   {3,7},{3,5},{3,5},{2,4},{1,5},{1,3},{0,6},
        {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, {0,0} },  // 9 TotalZeros
    {   {2,7},{2,5},{2,5},{2,5},{1,4},{0,6},{0,0},
        {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, {0,0} },  // 10 TotalZeros
    {   {3,8},{3,6},{1,6},{1,5},{0,5},{0,0},{0,0},
        {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, {0,0} },  // 11 TotalZeros
    {   {2,8},{2,6},{1,5},{0,5},{0,0},{0,0},{0,0},
        {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, {0,0} },  // 12 TotalZeros
    {   {3,9},{1,6},{0,6},{0,0},{0,0},{0,0},{0,0},
        {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, {0,0} },  // 13 TotalZeros
    {   {2,9},{0,6},{0,0},{0,0},{0,0},{0,0},{0,0},
        {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, {0,0} },  // 14 TotalZeros
    {   {1,9},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
        {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, {0,0} }   // 15 TotalZeros
};

static const struct_CodeEntry EncRuns[15][8] = {
    //    0     1     2     3     4     5     6+     <- (ZerosLeft-1)
    {   {1,1},{1,1},{3,2},{3,2},{3,2},{3,2},{7,3}, {0,0} }, // 0 RunBefore
    {   {0,1},{1,2},{2,2},{2,2},{2,2},{0,3},{6,3}, {0,0} }, // 1 RunBefore
    {   {0,0},{0,2},{1,2},{1,2},{3,3},{1,3},{5,3}, {0,0} }, // 2 RunBefore
    {   {0,0},{0,0},{0,2},{1,3},{2,3},{3,3},{4,3}, {0,0} }, // 3 RunBefore
    {   {0,0},{0,0},{0,0},{0,3},{1,3},{2,3},{3,3}, {0,0} }, // 4 RunBefore
    {   {0,0},{0,0},{0,0},{0,0},{0,3},{5,3},{2,3}, {0,0} }, // 5 RunBefore
    {   {0,0},{0,0},{0,0},{0,0},{0,0},{4,3},{1,3}, {0,0} }, // 6 RunBefore
    {   {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{1,4}, {0,0} }, // 7 RunBefore
    {   {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{1,5}, {0,0} }, // 8 RunBefore
    {   {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{1,6}, {0,0} }, // 9 RunBefore
    {   {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{1,7}, {0,0} }, // 10 RunBefore
    {   {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{1,8}, {0,0} }, // 11 RunBefore
    {   {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{1,9}, {0,0} }, // 12 RunBefore
    {   {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{1,10}, {0,0}}, // 13 RunBefore
    {   {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{1,11}, {0,0}}  // 14 RunBefore
};

static const Ipp32u ctx_neq1p1[8] = { 1, 2, 3, 4, 0, 0, 0, 0 };
static const Ipp32u ctx_ngt1[8] = { 5, 5, 5, 5, 6, 7, 8, 9 };
static const Ipp32u ctx_id_trans0[8] = { 1, 2, 3, 3, 4, 5, 6, 7 };
static const Ipp32u ctx_id_trans1[8] = { 4, 4, 4, 4, 5, 6, 7, 7 };
static const Ipp32u ctx_id_trans13[7] = { 4, 4, 4, 4, 5, 6, 6 };

// MSBIT replaces (Ipp32s)(log(float(arg + 1))/log(2.0))
// TODO - replace by intrinsic ?
static inline Ipp32s MSBIT (Ipp32u arg)
{
    Ipp32s res;
    for( res = 0; arg; arg >>= 1, res++);
    return res;
}

// See table 9-42 in H.264 standard
static const Ipp32u maxNumCoeffTable[] =
{
    16,
    15,
    16,
    4, // for NumC8x8 == 1 (4:2:0 sampling)
    15,
    64
};

// See table 9-34 of H.264 standard
const Ipp32u ctxIdxOffset_BlockCat01234_FrameCodedBlock_SignificantCoeffFlag = 105;
const Ipp32u ctxIdxOffset_BlockCat01234_FieldCodedBlock_SignificantCoeffFlag = 277;
const Ipp32u ctxIdxOffset_BlockCat01234_FrameCodedBlock_LastSignificantCoeffFlag = 166;
const Ipp32u ctxIdxOffset_BlockCat01234_FieldCodedBlock_LastSignificantCoeffFlag = 338;
const Ipp32u ctxIdxOffset_BlockCat01234_CoeffAbsLevelMinus1 = 227;

const Ipp32u ctxIdxOffset_BlockCat5_FrameCodedBlock_SignificantCoeffFlag = 402;
const Ipp32u ctxIdxOffset_BlockCat5_FieldCodedBlock_SignificantCoeffFlag = 436;
const Ipp32u ctxIdxOffset_BlockCat5_FrameCodedBlock_LastSignificantCoeffFlag = 417;
const Ipp32u ctxIdxOffset_BlockCat5_FieldCodedBlock_LastSignificantCoeffFlag = 451;
const Ipp32u ctxIdxOffset_BlockCat5_CoeffAbsLevelMinus1 = 426;

// See "Table 9-40 - Assignment of ctxIdxBlockCatOffset to ctxBlockCat for syntax elements coded_block_flag,
// significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1" in H.264 standard
static const Ipp32u ctxIdxBlockCatOffset_SignificantCoeffFlag_Table[14] = {
    0, 15, 29, 44, 47, 0, 0, 15, 29, 0, 0, 15, 29, 0
};
static const Ipp32u ctxIdxBlockCatOffset_LastSignificantCoeffFlag_Table[14] = {
    0, 15, 29, 44, 47, 0, 0, 15, 29, 0, 0, 15, 29, 0
};
static const Ipp32u ctxIdxBlockCatOffset_CoeffAbsLevelMinus1_Table[14] = {
    0, 10, 20, 30, 39, 0, 0, 10, 20, 0, 0, 10, 20, 0
};

// See Table 9-43 in H.264 standard
static const Ipp32u ctxIdxInc_BlockCat5913_FrameCodedBlock_SignificantCoeffFlag[63] = {
    0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5, 4, 4,  4,  4, 3,  3,  6,  7, 7, 7,  8,  9, 10,  9,  8,  7, 7, 6, 11, 12, 13, 11,  6,  7, 8, 9, 14, 10, 9,  8,  6, 11, 12, 13, 11, 6,  9, 14, 10, 9, 11, 12, 13, 11, 14, 10, 12
};
static const Ipp32u ctxIdxInc_BlockCat5913_FieldCodedBlock_SignificantCoeffFlag[63] = {
    0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 7, 8, 4, 5, 6, 9, 10, 10, 8, 11, 12, 11, 9, 9, 10, 10,  8, 11, 12, 11, 9, 9, 10, 10,  8, 11, 12, 11, 9, 9, 10, 10, 8, 13, 13,  9,  9, 10, 10, 8, 13, 13,  9, 9, 10, 10, 14, 14, 14, 14, 14
};
static const Ipp32u ctxIdxInc_BlockCat5913_LastSignificantCoeffFlag[63] = {
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,  2,  2, 2,  2,  2,  2, 2, 2,  2,  2,  2,  2,  2,  2, 3, 3,  3,  3,  3,  3,  3,  3, 4, 4,  4,  4, 4,  4,  4,  4,  5,  5,  5, 5,  6,  6,  6, 6,  7,  7,  7,  7,  8,  8,  8
};

// Returns the minimum of two unsigned 32-bit numbers
static Ipp32u Min_32u( Ipp32u a, Ipp32u b ) {
    if( a < b )
        return a;
    else
        return b;
}

// Returns the absolute value of signed 32-bit number
Ipp32u Abs_32s( Ipp32s n ) {
    if( n >= 0 )
        return n;
    else
        return -n;
}

typedef struct _IppvcCABACState_internal {
    Ipp32u* pBitStream;
    Ipp8u* pBitStreamStart;
    Ipp32u* pBitStreamEnd;

    Ipp32u lcodIOffset;
    Ipp32u lcodIRange;
    Ipp32u nBitsVacant;
    Ipp32u nRegister;
    Ipp32u nPreCabacBitOffset;

    Ipp8u contexts[CABAC_CONTEXT_ARRAY_LEN];
} IppvcCABACState_internal;

const Ipp8u h264_cabac_rangeTabLPS[128][4] =
{
    { 128, 176, 208, 240},
    { 128, 167, 197, 227},
    { 128, 158, 187, 216},
    { 123, 150, 178, 205},
    { 116, 142, 169, 195},
    { 111, 135, 160, 185},
    { 105, 128, 152, 175},
    { 100, 122, 144, 166},
    {  95, 116, 137, 158},
    {  90, 110, 130, 150},
    {  85, 104, 123, 142},
    {  81,  99, 117, 135},
    {  77,  94, 111, 128},
    {  73,  89, 105, 122},
    {  69,  85, 100, 116},
    {  66,  80,  95, 110},
    {  62,  76,  90, 104},
    {  59,  72,  86,  99},
    {  56,  69,  81,  94},
    {  53,  65,  77,  89},
    {  51,  62,  73,  85},
    {  48,  59,  69,  80},
    {  46,  56,  66,  76},
    {  43,  53,  63,  72},
    {  41,  50,  59,  69},
    {  39,  48,  56,  65},
    {  37,  45,  54,  62},
    {  35,  43,  51,  59},
    {  33,  41,  48,  56},
    {  32,  39,  46,  53},
    {  30,  37,  43,  50},
    {  29,  35,  41,  48},
    {  27,  33,  39,  45},
    {  26,  31,  37,  43},
    {  24,  30,  35,  41},
    {  23,  28,  33,  39},
    {  22,  27,  32,  37},
    {  21,  26,  30,  35},
    {  20,  24,  29,  33},
    {  19,  23,  27,  31},
    {  18,  22,  26,  30},
    {  17,  21,  25,  28},
    {  16,  20,  23,  27},
    {  15,  19,  22,  25},
    {  14,  18,  21,  24},
    {  14,  17,  20,  23},
    {  13,  16,  19,  22},
    {  12,  15,  18,  21},
    {  12,  14,  17,  20},
    {  11,  14,  16,  19},
    {  11,  13,  15,  18},
    {  10,  12,  15,  17},
    {  10,  12,  14,  16},
    {   9,  11,  13,  15},
    {   9,  11,  12,  14},
    {   8,  10,  12,  14},
    {   8,   9,  11,  13},
    {   7,   9,  11,  12},
    {   7,   9,  10,  12},
    {   7,   8,  10,  11},
    {   6,   8,   9,  11},
    {   6,   7,   9,  10},
    {   6,   7,   8,   9},
    {   2,   2,   2,   2},
//The same for valMPS=1
    { 128, 176, 208, 240},
    { 128, 167, 197, 227},
    { 128, 158, 187, 216},
    { 123, 150, 178, 205},
    { 116, 142, 169, 195},
    { 111, 135, 160, 185},
    { 105, 128, 152, 175},
    { 100, 122, 144, 166},
    {  95, 116, 137, 158},
    {  90, 110, 130, 150},
    {  85, 104, 123, 142},
    {  81,  99, 117, 135},
    {  77,  94, 111, 128},
    {  73,  89, 105, 122},
    {  69,  85, 100, 116},
    {  66,  80,  95, 110},
    {  62,  76,  90, 104},
    {  59,  72,  86,  99},
    {  56,  69,  81,  94},
    {  53,  65,  77,  89},
    {  51,  62,  73,  85},
    {  48,  59,  69,  80},
    {  46,  56,  66,  76},
    {  43,  53,  63,  72},
    {  41,  50,  59,  69},
    {  39,  48,  56,  65},
    {  37,  45,  54,  62},
    {  35,  43,  51,  59},
    {  33,  41,  48,  56},
    {  32,  39,  46,  53},
    {  30,  37,  43,  50},
    {  29,  35,  41,  48},
    {  27,  33,  39,  45},
    {  26,  31,  37,  43},
    {  24,  30,  35,  41},
    {  23,  28,  33,  39},
    {  22,  27,  32,  37},
    {  21,  26,  30,  35},
    {  20,  24,  29,  33},
    {  19,  23,  27,  31},
    {  18,  22,  26,  30},
    {  17,  21,  25,  28},
    {  16,  20,  23,  27},
    {  15,  19,  22,  25},
    {  14,  18,  21,  24},
    {  14,  17,  20,  23},
    {  13,  16,  19,  22},
    {  12,  15,  18,  21},
    {  12,  14,  17,  20},
    {  11,  14,  16,  19},
    {  11,  13,  15,  18},
    {  10,  12,  15,  17},
    {  10,  12,  14,  16},
    {   9,  11,  13,  15},
    {   9,  11,  12,  14},
    {   8,  10,  12,  14},
    {   8,   9,  11,  13},
    {   7,   9,  11,  12},
    {   7,   9,  10,  12},
    {   7,   8,  10,  11},
    {   6,   8,   9,  11},
    {   6,   7,   9,  10},
    {   6,   7,   8,   9},
    {   2,   2,   2,   2}
};

const Ipp8u h264_cabac_transTbl[2][128] = {
    { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
     27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
     39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
     51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
     62, 63,  0, 64, 65, 66, 66, 68, 68, 69, 70, 71,
     72, 73, 73, 75, 75, 76, 77, 77, 79, 79, 80, 80,
     82, 82, 83, 83, 85, 85, 86, 86, 87, 88, 88, 89,
     90, 90, 91, 91, 92, 93, 93, 94, 94, 94, 95, 96,
     96, 97, 97, 97, 98, 98, 99, 99, 99, 100, 100,
     100, 101, 101, 101, 102, 102, 127
    },
    { 64, 0, 1, 2, 2, 4, 4, 5, 6, 7, 8, 9, 9, 11, 11,
      12, 13, 13, 15, 15, 16, 16, 18, 18, 19, 19, 21,
      21, 22, 22, 23, 24, 24, 25, 26, 26, 27, 27, 28,
      29, 29, 30, 30, 30, 31, 32, 32, 33, 33, 33, 34,
      34, 35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38,
      63, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
      76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
      88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
      100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
      110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
      120, 121, 122, 123, 124, 125, 126, 126, 127
     }
};

typedef struct _MandN {
    Ipp16s m;
    Ipp16s n;
} MandN;


// See table 9-12 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_0_10[11] =
{
    {20, -15},
    {2, 54},
    {3, 74},
    {20, -15},
    {2, 54},
    {3, 74},
    {-28, 127},
    {-23, 104},
    {-6, 53},
    {-1, 54},
    {7, 51},
};

// See table 9-13 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_11_23[13][3] =
{
    {{23, 33}, {22, 25}, {29, 16}},
    {{23, 2}, {34, 0}, {25, 0}},
    {{21, 0}, {16, 0}, {14, 0}},
    {{1, 9}, {-2, 9}, {-10, 51}},
    {{0, 49}, {4, 41}, {-3, 62}},
    {{-37, 118}, {-29, 118}, {-27, 99}},
    {{5, 57}, {2, 65}, {26, 16}},
    {{-13, 78}, {-6, 71}, {-4, 85}},
    {{-11, 65}, {-13, 79}, {-24, 102}},
    {{1, 62}, {5, 52}, {5, 57}},
    {{12, 49}, {9, 50}, {6, 57}},
    {{-4, 73}, {-3, 70}, {-17, 73}},
    {{17, 50}, {10, 54}, {14, 57}},
};

// See table 9-14 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_24_39[16][3] =
{
    {{18, 64}, {26, 34}, {20, 40}},
    {{9, 43}, {19, 22}, {20, 10}},
    {{29, 0}, {40, 0}, {29, 0}},
    {{26, 67}, {57, 2}, {54, 0}},
    {{16, 90}, {41, 36}, {37, 42}},
    {{9, 104}, {26, 69}, {12, 97}},
    {{-46, 127}, {-45, 127}, {-32, 127}},
    {{-20, 104}, {-15, 101}, {-22, 117}},
    {{1, 67}, {-4, 76}, {-2, 74}},
    {{-13, 78}, {-6, 71}, {-4, 85}},
    {{-11, 65}, {-13, 79}, {-24, 102}},
    {{1, 62}, {5, 52}, {5, 57}},
    {{-6, 86}, {6, 69}, {-6, 93}},
    {{-17, 95}, {-13, 90}, {-14, 88}},
    {{-6, 61}, {0, 52}, {-6, 44}},
    {{9, 45}, {8, 43}, {4, 55}},
};

// See table 9-15 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_40_53[14][3] =
{
    {{-3, 69}, {-2, 69}, {-11, 89}},
    {{-6, 81}, {-5, 82}, {-15, 103}},
    {{-11, 96}, {-10, 96}, {-21, 116}},
    {{6, 55}, {2, 59}, {19, 57}},
    {{7, 67}, {2, 75}, {20, 58}},
    {{-5, 86}, {-3, 87}, {4, 84}},
    {{2, 88}, {-3, 100}, {6, 96}},
    {{0, 58}, {1, 56}, {1, 63}},
    {{-3, 76}, {-3, 74}, {-5, 85}},
    {{-10, 94}, {-6, 85}, {-13, 106}},
    {{5, 54}, {0, 59}, {5, 63}},
    {{4, 69}, {-3, 81}, {6, 75}},
    {{-3, 81}, {-7, 86}, {-3, 90}},
    {{0, 88}, {-5, 95}, {-1, 101}},
};

// See table 9-16 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_54_59[6][3] =
{
    {{-7, 67}, {-1, 66}, {3, 55}},
    {{-5, 74}, {-1, 77}, {-4, 79}},
    {{-4, 74}, {1, 70}, {-2, 75}},
    {{-5, 80}, {-2, 86}, {-12, 97}},
    {{-7, 72}, {-5, 72}, {-7, 50}},
    {{1, 58}, {0, 61}, {1, 60}},
};

// See table 9-17 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_60_69[10] =
{
    {0, 41},
    {0, 63},
    {0, 63},
    {0, 63},
    {-9, 83},
    {4, 86},
    {0, 97},
    {-7, 72},
    {13, 41},
    {3, 62},
};

// See table 9-18 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_70_104_intra[35] =
{
    {0, 11},
    {1, 55},
    {0, 69},
    {-17, 127},
    {-13, 102},
    {0, 82},
    {-7, 74},
    {-21, 107},
    {-27, 127},
    {-31, 127},
    {-24, 127},
    {-18, 95},
    {-27, 127},
    {-21, 114},
    {-30, 127},
    {-17, 123},
    {-12, 115},
    {-16, 122},
    {-11, 115},
    {-12, 63},
    {-2, 68},
    {-15, 84},
    {-13, 104},
    {-3, 70},
    {-8, 93},
    {-10, 90},
    {-30, 127},
    {-1, 74},
    {-6, 97},
    {-7, 91},
    {-20, 127},
    {-4, 56},
    {-5, 82},
    {-7, 76},
    {-22, 125},
};

// See table 9-19 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_105_165_intra[61] =
{
    {-7, 93},
    {-11, 87},
    {-3, 77},
    {-5, 71},
    {-4, 63},
    {-4, 68},
    {-12, 84},
    {-7, 62},
    {-7, 65},
    {8, 61},
    {5, 56},
    {-2, 66},
    {1, 64},
    {0, 61},
    {-2, 78},
    {1, 50},
    {7, 52},
    {10, 35},
    {0, 44},
    {11, 38},
    {1, 45},
    {0, 46},
    {5, 44},
    {31, 17},
    {1, 51},
    {7, 50},
    {28, 19},
    {16, 33},
    {14, 62},
    {-13, 108},
    {-15, 100},
    {-13, 101},
    {-13, 91},
    {-12, 94},
    {-10, 88},
    {-16, 84},
    {-10, 86},
    {-7, 83},
    {-13, 87},
    {-19, 94},
    {1, 70},
    {0, 72},
    {-5, 74},
    {18, 59},
    {-8, 102},
    {-15, 100},
    {0, 95},
    {-4, 75},
    {2, 72},
    {-11, 75},
    {-3, 71},
    {15, 46},
    {-13, 69},
    {0, 62},
    {0, 65},
    {21, 37},
    {-15, 72},
    {9, 57},
    {16, 54},
    {0, 62},
    {12, 72},
};

// See table 9-20 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_166_226_intra[61] =
{
    {24, 0},
    {15, 9},
    {8, 25},
    {13, 18},
    {15, 9},
    {13, 19},
    {10, 37},
    {12, 18},
    {6, 29},
    {20, 33},
    {15, 30},
    {4, 45},
    {1, 58},
    {0, 62},
    {7, 61},
    {12, 38},
    {11, 45},
    {15, 39},
    {11, 42},
    {13, 44},
    {16, 45},
    {12, 41},
    {10, 49},
    {30, 34},
    {18, 42},
    {10, 55},
    {17, 51},
    {17, 46},
    {0, 89},
    {26, -19},
    {22, -17},
    {26, -17},
    {30, -25},
    {28, -20},
    {33, -23},
    {37, -27},
    {33, -23},
    {40, -28},
    {38, -17},
    {33, -11},
    {40, -15},
    {41, -6},
    {38, 1},
    {41, 17},
    {30, -6},
    {27, 3},
    {26, 22},
    {37, -16},
    {35, -4},
    {38, -8},
    {38, -3},
    {37, 3},
    {38, 5},
    {42, 0},
    {35, 16},
    {39, 22},
    {14, 48},
    {27, 37},
    {21, 60},
    {12, 68},
    {2, 97},
};

// See table 9-21 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_227_275_intra[49] =
{
    {-3, 71},
    {-6, 42},
    {-5, 50},
    {-3, 54},
    {-2, 62},
    {0, 58},
    {1, 63},
    {-2, 72},
    {-1, 74},
    {-9, 91},
    {-5, 67},
    {-5, 27},
    {-3, 39},
    {-2, 44},
    {0, 46},
    {-16, 64},
    {-8, 68},
    {-10, 78},
    {-6, 77},
    {-10, 86},
    {-12, 92},
    {-15, 55},
    {-10, 60},
    {-6, 62},
    {-4, 65},
    {-12, 73},
    {-8, 76},
    {-7, 80},
    {-9, 88},
    {-17, 110},
    {-11, 97},
    {-20, 84},
    {-11, 79},
    {-6, 73},
    {-4, 74},
    {-13, 86},
    {-13, 96},
    {-11, 97},
    {-19, 117},
    {-8, 78},
    {-5, 33},
    {-4, 48},
    {-2, 53},
    {-3, 62},
    {-13, 71},
    {-10, 79},
    {-12, 86},
    {-13, 90},
    {-14, 97},
};

// See table 9-22 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_277_337_intra[61] =
{
    {-6, 93},
    {-6, 84},
    {-8, 79},
    {0, 66},
    {-1, 71},
    {0, 62},
    {-2, 60},
    {-2, 59},
    {-5, 75},
    {-3, 62},
    {-4, 58},
    {-9, 66},
    {-1, 79},
    {0, 71},
    {3, 68},
    {10, 44},
    {-7, 62},
    {15, 36},
    {14, 40},
    {16, 27},
    {12, 29},
    {1, 44},
    {20, 36},
    {18, 32},
    {5, 42},
    {1, 48},
    {10, 62},
    {17, 46},
    {9, 64},
    {-12, 104},
    {-11, 97},
    {-16, 96},
    {-7, 88},
    {-8, 85},
    {-7, 85},
    {-9, 85},
    {-13, 88},
    {4, 66},
    {-3, 77},
    {-3, 76},
    {-6, 76},
    {10, 58},
    {-1, 76},
    {-1, 83},
    {-7, 99},
    {-14, 95},
    {2, 95},
    {0, 76},
    {-5, 74},
    {0, 70},
    {-11, 75},
    {1, 68},
    {0, 65},
    {-14, 73},
    {3, 62},
    {4, 62},
    {-1, 68},
    {-13, 75},
    {11, 55},
    {5, 64},
    {12, 70},
};

// See table 9-23 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_338_398_intra[61] =
{
    {15, 6},
    {6, 19},
    {7, 16},
    {12, 14},
    {18, 13},
    {13, 11},
    {13, 15},
    {15, 16},
    {12, 23},
    {13, 23},
    {15, 20},
    {14, 26},
    {14, 44},
    {17, 40},
    {17, 47},
    {24, 17},
    {21, 21},
    {25, 22},
    {31, 27},
    {22, 29},
    {19, 35},
    {14, 50},
    {10, 57},
    {7, 63},
    {-2, 77},
    {-4, 82},
    {-3, 94},
    {9, 69},
    {-12, 109},
    {36, -35},
    {36, -34},
    {32, -26},
    {37, -30},
    {44, -32},
    {34, -18},
    {34, -15},
    {40, -15},
    {33, -7},
    {35, -5},
    {33, 0},
    {38, 2},
    {33, 13},
    {23, 35},
    {13, 58},
    {29, -3},
    {26, 0},
    {22, 30},
    {31, -7},
    {35, -15},
    {34, -3},
    {34, 3},
    {36, -1},
    {34, 5},
    {32, 11},
    {35, 5},
    {34, 12},
    {39, 11},
    {30, 29},
    {34, 26},
    {29, 39},
    {19, 66},
};

// See table 9-16 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_399_401_intra[3] =
{
    {31,21},
    {31,31},
    {25,50},
};

// See table 9-24 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_402_459_intra[58] =
{
    {-17,120},
    {-20,112},
    {-18,114},
    {-11, 85},
    {-15, 92},
    {-14, 89},
    {-26, 71},
    {-15, 81},
    {-14, 80},
    {  0, 68},
    {-14, 70},
    {-24, 56},
    {-23, 68},
    {-24, 50},
    {-11, 74},
    { 23,-13},
    { 26,-13},
    { 40,-15},
    { 49,-14},
    { 44,  3},
    { 45,  6},
    { 44, 34},
    { 33, 54},
    { 19, 82},
    { -3, 75},
    { -1, 23},
    {  1, 34},
    {  1, 43},
    {  0, 54},
    { -2, 55},
    {  0, 61},
    {  1, 64},
    {  0, 68},
    { -9, 92},
    {-14,106},
    {-13, 97},
    {-15, 90},
    {-12, 90},
    {-18, 88},
    {-10, 73},
    { -9, 79},
    {-14, 86},
    {-10, 73},
    {-10, 70},
    {-10, 69},
    { -5, 66},
    { -9, 64},
    { -5, 58},
    {  2, 59},
    { 21,-10},
    { 24,-11},
    { 28, -8},
    { 28, -1},
    { 29,  3},
    { 29,  9},
    { 35, 20},
    { 29, 36},
    { 14, 67},
};

// See table 9-18 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_70_104_inter[35][3] =
{
    {{0, 45}, {13, 15}, {7, 34}},
    {{-4, 78}, {7, 51}, {-9, 88}},
    {{-3, 96}, {2, 80}, {-20, 127}},
    {{-27, 126}, {-39, 127}, {-36, 127}},
    {{-28, 98}, {-18, 91}, {-17, 91}},
    {{-25, 101}, {-17, 96}, {-14, 95}},
    {{-23, 67}, {-26, 81}, {-25, 84}},
    {{-28, 82}, {-35, 98}, {-25, 86}},
    {{-20, 94}, {-24, 102}, {-12, 89}},
    {{-16, 83}, {-23, 97}, {-17, 91}},
    {{-22, 110}, {-27, 119}, {-31, 127}},
    {{-21, 91}, {-24, 99}, {-14, 76}},
    {{-18, 102}, {-21, 110}, {-18, 103}},
    {{-13, 93}, {-18, 102}, {-13, 90}},
    {{-29, 127}, {-36, 127}, {-37, 127}},
    {{-7, 92}, {0, 80}, {11, 80}},
    {{-5, 89}, {-5, 89}, {5, 76}},
    {{-7, 96}, {-7, 94}, {2, 84}},
    {{-13, 108}, {-4, 92}, {5, 78}},
    {{-3, 46}, {0, 39}, {-6, 55}},
    {{-1, 65}, {0, 65}, {4, 61}},
    {{-1, 57}, {-15, 84}, {-14, 83}},
    {{-9, 93}, {-35, 127}, {-37, 127}},
    {{-3, 74}, {-2, 73}, {-5, 79}},
    {{-9, 92}, {-12, 104}, {-11, 104}},
    {{-8, 87}, {-9, 91}, {-11, 91}},
    {{-23, 126}, {-31, 127}, {-30, 127}},
    {{5, 54}, {3, 55}, {0, 65}},
    {{6, 60}, {7, 56}, {-2, 79}},
    {{6, 59}, {7, 55}, {0, 72}},
    {{6, 69}, {8, 61}, {-4, 92}},
    {{-1, 48}, {-3, 53}, {-6, 56}},
    {{0, 68}, {0, 68}, {3, 68}},
    {{-4, 69}, {-7, 74}, {-8, 71}},
    {{-8, 88}, {-9, 88}, {-13, 98}},
};

// See table 9-19 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_105_165_inter[61][3] =
{
    {{-2, 85}, {-13, 103}, {-4, 86}},
    {{-6, 78}, {-13, 91}, {-12, 88}},
    {{-1, 75}, {-9, 89}, {-5, 82}},
    {{-7, 77}, {-14, 92}, {-3, 72}},
    {{2, 54}, {-8, 76}, {-4, 67}},
    {{5, 50}, {-12, 87}, {-8, 72}},
    {{-3, 68}, {-23, 110}, {-16, 89}},
    {{1, 50}, {-24, 105}, {-9, 69}},
    {{6, 42}, {-10, 78}, {-1, 59}},
    {{-4, 81}, {-20, 112}, {5, 66}},
    {{1, 63}, {-17, 99}, {4, 57}},
    {{-4, 70}, {-78, 127}, {-4, 71}},
    {{0, 67}, {-70, 127}, {-2, 71}},
    {{2, 57}, {-50, 127}, {2, 58}},
    {{-2, 76}, {-46, 127}, {-1, 74}},
    {{11, 35}, {-4, 66}, {-4, 44}},
    {{4, 64}, {-5, 78}, {-1, 69}},
    {{1, 61}, {-4, 71}, {0, 62}},
    {{11, 35}, {-8, 72}, {-7, 51}},
    {{18, 25}, {2, 59}, {-4, 47}},
    {{12, 24}, {-1, 55}, {-6, 42}},
    {{13, 29}, {-7, 70}, {-3, 41}},
    {{13, 36}, {-6, 75}, {-6, 53}},
    {{-10, 93}, {-8, 89}, {8, 76}},
    {{-7, 73}, {-34, 119}, {-9, 78}},
    {{-2, 73}, {-3, 75}, {-11, 83}},
    {{13, 46}, {32, 20}, {9, 52}},
    {{9, 49}, {30, 22}, {0, 67}},
    {{-7, 100}, {-44, 127}, {-5, 90}},
    {{9, 53}, {0, 54}, {1, 67}},
    {{2, 53}, {-5, 61}, {-15, 72}},
    {{5, 53}, {0, 58}, {-5, 75}},
    {{-2, 61}, {-1, 60}, {-8, 80}},
    {{0, 56}, {-3, 61}, {-21, 83}},
    {{0, 56}, {-8, 67}, {-21, 64}},
    {{-13, 63}, {-25, 84}, {-13, 31}},
    {{-5, 60}, {-14, 74}, {-25, 64}},
    {{-1, 62}, {-5, 65}, {-29, 94}},
    {{4, 57}, {5, 52}, {9, 75}},
    {{-6, 69}, {2, 57}, {17, 63}},
    {{4, 57}, {0, 61}, {-8, 74}},
    {{14, 39}, {-9, 69}, {-5, 35}},
    {{4, 51}, {-11, 70}, {-2, 27}},
    {{13, 68}, {18, 55}, {13, 91}},
    {{3, 64}, {-4, 71}, {3, 65}},
    {{1, 61}, {0, 58}, {-7, 69}},
    {{9, 63}, {7, 61}, {8, 77}},
    {{7, 50}, {9, 41}, {-10, 66}},
    {{16, 39}, {18, 25}, {3, 62}},
    {{5, 44}, {9, 32}, {-3, 68}},
    {{4, 52}, {5, 43}, {-20, 81}},
    {{11, 48}, {9, 47}, {0, 30}},
    {{-5, 60}, {0, 44}, {1, 7}},
    {{-1, 59}, {0, 51}, {-3, 23}},
    {{0, 59}, {2, 46},{-21, 74}},
    {{22, 33}, {19, 38}, {16, 66}},
    {{5, 44}, {-4, 66}, {-23, 124}},
    {{14, 43}, {15, 38}, {17, 37}},
    {{-1, 78}, {12, 42}, {44, -18}},
    {{0, 60}, {9, 34}, {50, -34}},
    {{9, 69}, {0, 89}, {-22, 127}},
};

// See table 9-20 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_166_226_inter[61][3] =
{
    {{11, 28}, {4, 45}, {4, 39}},
    {{2, 40}, {10, 28}, {0, 42}},
    {{3, 44}, {10, 31}, {7, 34}},
    {{0, 49}, {33, -11}, {11, 29}},
    {{0, 46}, {52, -43}, {8, 31}},
    {{2, 44}, {18, 15}, {6, 37}},
    {{2, 51}, {28, 0}, {7, 42}},
    {{0, 47}, {35, -22}, {3, 40}},
    {{4, 39}, {38, -25}, {8, 33}},
    {{2, 62}, {34, 0}, {13, 43}},
    {{6, 46}, {39, -18}, {13, 36}},
    {{0, 54}, {32, -12}, {4, 47}},
    {{3, 54}, {102, -94}, {3, 55}},
    {{2, 58}, {0, 0}, {2, 58}},
    {{4, 63}, {56, -15}, {6, 60}},
    {{6, 51}, {33, -4}, {8, 44}},
    {{6, 57}, {29, 10}, {11, 44}},
    {{7, 53}, {37, -5}, {14, 42}},
    {{6, 52}, {51, -29}, {7, 48}},
    {{6, 55}, {39, -9}, {4, 56}},
    {{11, 45}, {52, -34}, {4, 52}},
    {{14, 36}, {69, -58}, {13, 37}},
    {{8, 53}, {67, -63}, {9, 49}},
    {{-1, 82}, {44, -5}, {19, 58}},
    {{7, 55}, {32, 7}, {10, 48}},
    {{-3, 78}, {55, -29}, {12, 45}},
    {{15, 46}, {32, 1}, {0, 69}},
    {{22, 31}, {0, 0}, {20, 33}},
    {{-1, 84}, {27, 36}, {8, 63}},
    {{25, 7}, {33, -25}, {35, -18}},
    {{30, -7}, {34, -30}, {33, -25}},
    {{28, 3}, {36, -28}, {28, -3}},
    {{28, 4}, {38, -28}, {24, 10}},
    {{32, 0}, {38, -27}, {27, 0}},
    {{34, -1}, {34, -18}, {34, -14}},
    {{30, 6}, {35, -16}, {52, -44}},
    {{30, 6}, {34, -14}, {39, -24}},
    {{32, 9}, {32, -8}, {19, 17}},
    {{31, 19}, {37, -6}, {31, 25}},
    {{26, 27}, {35, 0}, {36, 29}},
    {{26, 30}, {30, 10}, {24, 33}},
    {{37, 20}, {28, 18}, {34, 15}},
    {{28, 34}, {26, 25}, {30, 20}},
    {{17, 70}, {29, 41}, {22, 73}},
    {{1, 67}, {0, 75}, {20, 34}},
    {{5, 59}, {2, 72}, {19, 31}},
    {{9, 67}, {8, 77}, {27, 44}},
    {{16, 30}, {14, 35}, {19, 16}},
    {{18, 32}, {18, 31}, {15, 36}},
    {{18, 35}, {17, 35}, {15, 36}},
    {{22, 29}, {21, 30}, {21, 28}},
    {{24, 31}, {17, 45}, {25, 21}},
    {{23, 38}, {20, 42}, {30, 20}},
    {{18, 43}, {18, 45}, {31, 12}},
    {{20, 41}, {27, 26}, {27, 16}},
    {{11, 63}, {16, 54}, {24, 42}},
    {{9, 59}, {7, 66}, {0, 93}},
    {{9, 64}, {16, 56}, {14, 56}},
    {{-1, 94}, {11, 73}, {15, 57}},
    {{-2, 89}, {10, 67}, {26, 38}},
    {{-9, 108}, {-10, 116}, {-24, 127}},
};

// See table 9-21 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_227_275_inter[49][3] =
{
    {{-6, 76}, {-23, 112}, {-24, 115}},
    {{-2, 44}, {-15, 71}, {-22, 82}},
    {{0, 45}, {-7, 61}, {-9, 62}},
    {{0, 52}, {0, 53}, {0, 53}},
    {{-3, 64}, {-5, 66}, {0, 59}},
    {{-2, 59}, {-11, 77}, {-14, 85}},
    {{-4, 70}, {-9, 80}, {-13, 89}},
    {{-4, 75}, {-9, 84}, {-13, 94}},
    {{-8, 82}, {-10, 87}, {-11, 92}},
    {{-17, 102}, {-34, 127}, {-29, 127}},
    {{-9, 77}, {-21, 101}, {-21, 100}},
    {{3, 24}, {-3, 39}, {-14, 57}},
    {{0, 42}, {-5, 53}, {-12, 67}},
    {{0, 48}, {-7, 61}, {-11, 71}},
    {{0, 55}, {-11, 75}, {-10, 77}},
    {{-6, 59}, {-15, 77}, {-21, 85}},
    {{-7, 71}, {-17, 91}, {-16, 88}},
    {{-12, 83}, {-25, 107}, {-23, 104}},
    {{-11, 87}, {-25, 111}, {-15, 98}},
    {{-30, 119}, {-28, 122}, {-37, 127}},
    {{1, 58}, {-11, 76}, {-10, 82}},
    {{-3, 29}, {-10, 44}, {-8, 48}},
    {{-1, 36}, {-10, 52}, {-8, 61}},
    {{1, 38}, {-10, 57}, {-8, 66}},
    {{2, 43}, {-9, 58}, {-7, 70}},
    {{-6, 55}, {-16, 72}, {-14, 75}},
    {{0, 58}, {-7, 69}, {-10, 79}},
    {{0, 64}, {-4, 69}, {-9, 83}},
    {{-3, 74}, {-5, 74}, {-12, 92}},
    {{-10, 90}, {-9, 86}, {-18, 108}},
    {{0, 70}, {2, 66}, {-4, 79}},
    {{-4, 29}, {-9, 34}, {-22, 69}},
    {{5, 31}, {1, 32}, {-16, 75}},
    {{7, 42}, {11, 31}, {-2, 58}},
    {{1, 59}, {5, 52}, {1, 58}},
    {{-2, 58}, {-2, 55}, {-13, 78}},
    {{-3, 72}, {-2, 67}, {-9, 83}},
    {{-3, 81}, {0, 73}, {-4, 81}},
    {{-11, 97}, {-8, 89}, {-13, 99}},
    {{0, 58}, {3, 52}, {-13, 81}},
    {{8, 5}, {7, 4}, {-6, 38}},
    {{10, 14}, {10, 8}, {-13, 62}},
    {{14, 18}, {17, 8}, {-6, 58}},
    {{13, 27}, {16, 19}, {-2, 59}},
    {{2, 40}, {3, 37}, {-16, 73}},
    {{0, 58}, {-1, 61}, {-10, 76}},
    {{-3, 70}, {-5, 73}, {-13, 86}},
    {{-6, 79}, {-1, 70}, {-9, 83}},
    {{-8, 85}, {-4, 78}, {-10, 87}},
};

// See table 9-22 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_277_337_inter[61][3] =
{
    {{-13, 106}, {-21, 126}, {-22, 127}},
    {{-16, 106}, {-23, 124}, {-25, 127}},
    {{-10, 87}, {-20, 110}, {-25, 120}},
    {{-21, 114}, {-26, 126}, {-27, 127}},
    {{-18, 110}, {-25, 124}, {-19, 114}},
    {{-14, 98}, {-17, 105}, {-23, 117}},
    {{-22, 110}, {-27, 121}, {-25, 118}},
    {{-21, 106}, {-27, 117}, {-26, 117}},
    {{-18, 103}, {-17, 102}, {-24, 113}},
    {{-21, 107}, {-26, 117}, {-28, 118}},
    {{-23, 108}, {-27, 116}, {-31, 120}},
    {{-26, 112}, {-33, 122}, {-37, 124}},
    {{-10, 96}, {-10, 95}, {-10, 94}},
    {{-12, 95}, {-14, 100}, {-15, 102}},
    {{-5, 91}, {-8, 95}, {-10, 99}},
    {{-9, 93}, {-17, 111}, {-13, 106}},
    {{-22, 94}, {-28, 114}, {-50, 127}},
    {{-5, 86}, {-6, 89}, {-5, 92}},
    {{9, 67}, {-2, 80}, {17, 57}},
    {{-4, 80}, {-4, 82}, {-5, 86}},
    {{-10, 85}, {-9, 85}, {-13, 94}},
    {{-1, 70}, {-8, 81}, {-12, 91}},
    {{7, 60}, {-1, 72}, {-2, 77}},
    {{9, 58}, {5, 64}, {0, 71}},
    {{5, 61}, {1, 67}, {-1, 73}},
    {{12, 50}, {9, 56}, {4, 64}},
    {{15, 50}, {0, 69}, {-7, 81}},
    {{18, 49}, {1, 69}, {5, 64}},
    {{17, 54}, {7, 69}, {15, 57}},
    {{10, 41}, {-7, 69}, {1, 67}},
    {{7, 46}, {-6, 67}, {0, 68}},
    {{-1, 51}, {-16, 77}, {-10, 67}},
    {{7, 49}, {-2, 64}, {1, 68}},
    {{8, 52}, {2, 61}, {0, 77}},
    {{9, 41}, {-6, 67}, {2, 64}},
    {{6, 47}, {-3, 64}, {0, 68}},
    {{2, 55}, {2, 57}, {-5, 78}},
    {{13, 41}, {-3, 65}, {7, 55}},
    {{10, 44}, {-3, 66}, {5, 59}},
    {{6, 50}, {0, 62}, {2, 65}},
    {{5, 53}, {9, 51}, {14, 54}},
    {{13, 49}, {-1, 66}, {15, 44}},
    {{4, 63}, {-2, 71}, {5, 60}},
    {{6, 64}, {-2, 75}, {2, 70}},
    {{-2, 69}, {-1, 70}, {-2, 76}},
    {{-2, 59}, {-9, 72}, {-18, 86}},
    {{6, 70}, {14, 60}, {12, 70}},
    {{10, 44}, {16, 37}, {5, 64}},
    {{9, 31}, {0, 47}, {-12, 70}},
    {{12, 43}, {18, 35}, {11, 55}},
    {{3, 53}, {11, 37}, {5, 56}},
    {{14, 34}, {12, 41}, {0, 69}},
    {{10, 38}, {10, 41}, {2, 65}},
    {{-3, 52}, {2, 48}, {-6, 74}},
    {{13, 40}, {12, 41}, {5, 54}},
    {{17, 32}, {13, 41}, {7, 54}},
    {{7, 44}, {0, 59}, {-6, 76}},
    {{7, 38}, {3, 50}, {-11, 82}},
    {{13, 50}, {19, 40}, {-2, 77}},
    {{10, 57}, {3, 66}, {-2, 77}},
    {{26, 43}, {18, 50}, {25, 42}},
};

// See table 9-23 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_338_398_inter[61][3] =
{
    {{14, 11}, {19, -6}, {17, -13}},
    {{11, 14}, {18, -6}, {16, -9}},
    {{9, 11}, {14, 0}, {17, -12}},
    {{18, 11}, {26, -12}, {27, -21}},
    {{21, 9}, {31, -16}, {37, -30}},
    {{23, -2}, {33, -25}, {41, -40}},
    {{32, -15}, {33, -22}, {42, -41}},
    {{32, -15}, {37, -28}, {48, -47}},
    {{34, -21}, {39, -30}, {39, -32}},
    {{39, -23}, {42, -30}, {46, -40}},
    {{42, -33}, {47, -42}, {52, -51}},
    {{41, -31}, {45, -36}, {46, -41}},
    {{46, -28}, {49, -34}, {52, -39}},
    {{38, -12}, {41, -17}, {43, -19}},
    {{21, 29}, {32, 9}, {32, 11}},
    {{45, -24}, {69, -71}, {61, -55}},
    {{53, -45}, {63, -63}, {56, -46}},
    {{48, -26}, {66, -64}, {62, -50}},
    {{65, -43}, {77, -74}, {81, -67}},
    {{43, -19}, {54, -39}, {45, -20}},
    {{39, -10}, {52, -35}, {35, -2}},
    {{30, 9}, {41, -10}, {28, 15}},
    {{18, 26}, {36, 0}, {34, 1}},
    {{20, 27}, {40, -1}, {39, 1}},
    {{0, 57}, {30, 14}, {30, 17}},
    {{-14, 82}, {28, 26}, {20, 38}},
    {{-5, 75}, {23, 37}, {18, 45}},
    {{-19, 97}, {12, 55}, {15, 54}},
    {{-35, 125}, {11, 65}, {0, 79}},
    {{27, 0}, {37, -33}, {36, -16}},
    {{28, 0}, {39, -36}, {37, -14}},
    {{31, -4}, {40, -37}, {37, -17}},
    {{27, 6}, {38, -30}, {32, 1}},
    {{34, 8}, {46, -33}, {34, 15}},
    {{30, 10}, {42, -30}, {29, 15}},
    {{24, 22}, {40, -24}, {24, 25}},
    {{33, 19}, {49, -29}, {34, 22}},
    {{22, 32}, {38, -12}, {31, 16}},
    {{26, 31}, {40, -10}, {35, 18}},
    {{21, 41}, {38, -3}, {31, 28}},
    {{26, 44}, {46, -5}, {33, 41}},
    {{23, 47}, {31, 20}, {36, 28}},
    {{16, 65}, {29, 30}, {27, 47}},
    {{14, 71}, {25, 44}, {21, 62}},
    {{8, 60}, {12, 48}, {18, 31}},
    {{6, 63}, {11, 49}, {19, 26}},
    {{17, 65}, {26, 45}, {36, 24}},
    {{21, 24}, {22, 22}, {24, 23}},
    {{23, 20}, {23, 22}, {27, 16}},
    {{26, 23}, {27, 21}, {24, 30}},
    {{27, 32}, {33, 20}, {31, 29}},
    {{28, 23}, {26, 28}, {22, 41}},
    {{28, 24}, {30, 24}, {22, 42}},
    {{23, 40}, {27, 34}, {16, 60}},
    {{24, 32}, {18, 42}, {15, 52}},
    {{28, 29}, {25, 39}, {14, 60}},
    {{23, 42}, {18, 50}, {3, 78}},
    {{19, 57}, {12, 70}, {-16, 123}},
    {{22, 53}, {21, 54}, {21, 53}},
    {{22, 61}, {14, 71}, {22, 56}},
    {{11, 86}, {11, 83}, {25, 61}},
};

// See table 9-16 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_399_401_inter[3][3] =
{
    {{12, 40}, {25, 32}, {21, 33}},
    {{11, 51}, {21, 49}, {19, 50}},
    {{14, 59}, {21, 54}, {17, 61}},
};

const MandN h264_cabac_M_and_N_for_ctxIdx_402_459_inter[58][3] =
{
    {{-4, 79}, {-5, 85}, {-3, 78}},
    {{-7, 71}, {-6, 81}, {-8, 74}},
    {{-5, 69}, {-10,77}, {-9, 72}},
    {{-9, 70}, {-7, 81}, {-10,72}},
    {{-8 ,66}, {-17,80}, {-18,75}},
    {{-10,68}, {-18,73}, {-12,71}},
    {{-19,73}, {-4, 74}, {-11,63}},
    {{-12,69}, {-10,83}, {-5, 70}},
    {{-16,70}, {-9, 71}, {-17,75}},
    {{-15,67}, {-9, 67}, {-14,72}},
    {{-20,62}, {-1, 61}, {-16,67}},
    {{-19,70}, {-8, 66}, {-8, 53}},
    {{-16,66}, {-14,66}, {-14,59}},
    {{-22,65}, {0,  59}, {-9, 52}},
    {{-20,63}, {2,  59}, {-11,68}},
    {{9,  -2}, {17,-10}, {9,  -2}},
    {{26, -9}, {32,-13}, {30,-10}},
    {{33, -9}, {42, -9}, {31, -4}},
    {{39, -7}, {49, -5}, {33, -1}},
    {{41, -2}, {53,  0}, {33,  7}},
    {{45,  3}, {64,  3}, {31, 12}},
    {{49,  9}, {68, 10}, {37, 23}},
    {{45, 27}, {66, 27}, {31, 38}},
    {{36, 59}, {47, 57}, {20, 64}},
    {{-6, 66}, {-5, 71}, {-9, 71}},
    {{-7, 35}, {0,  24}, {-7, 37}},
    {{-7, 42}, {-1, 36}, {-8, 44}},
    {{-8, 45}, {-2, 42}, {-11,49}},
    {{-5, 48}, {-2, 52}, {-10,56}},
    {{-12,56}, {-9, 57}, {-12,59}},
    {{-6, 60}, {-6, 63}, {-8, 63}},
    {{-5, 62}, {-4, 65}, {-9, 67}},
    {{-8, 66}, {-4, 67}, {-6, 68}},
    {{-8, 76}, {-7, 82}, {-10,79}},
    {{-5, 85}, {-3, 81}, {-3, 78}},
    {{-6, 81}, {-3, 76}, {-8, 74}},
    {{-10,77}, {-7, 72}, {-9, 72}},
    {{-7, 81}, {-6, 78}, {-10,72}},
    {{-17,80}, {-12,72}, {-18,75}},
    {{-18,73}, {-14,68}, {-12,71}},
    {{-4, 74}, {-3, 70}, {-11,63}},
    {{-10,83}, {-6, 76}, {-5, 70}},
    {{-9, 71}, {-5, 66}, {-17,75}},
    {{-9, 67}, {-5, 62}, {-14,72}},
    {{-1, 61}, {0,  57}, {-16,67}},
    {{-8, 66}, {-4, 61}, {-8, 53}},
    {{-14,66}, {-9, 60}, {-14,59}},
    {{0,  59}, {1,  54}, {-9, 52}},
    {{2,  59}, {2,  58}, {-11,68}},
    {{21,-13}, {17,-10}, {9,  -2}},
    {{33,-14}, {32,-13}, {30,-10}},
    {{39, -7}, {42, -9}, {31, -4}},
    {{46, -2}, {49, -5}, {33, -1}},
    {{51,  2}, {53,  0}, {33,  7}},
    {{60,  6}, {64,  3}, {31, 12}},
    {{61, 17}, {68, 10}, {37, 23}},
    {{55, 34}, {66, 27}, {31, 38}},
    {{42, 62}, {47, 57}, {20, 64}},
};

// See table G-12 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_1024_1026_intra[3] =
{
    {-14, 138}, {-22, 140},  {-11, 99},
};

const MandN h264_cabac_M_and_N_for_ctxIdx_1024_1026_inter[3] =
{
    {0, 75}, {2, 65},  {2, 59},
};

// See table G-13 of H.264 standard
const MandN h264_cabac_M_and_N_for_ctxIdx_1027_1030[4] =
{
    {-6, 67}, {-6, 67}, {-23, 104} ,  {-35,  106}
};

/* helper functions */

// Swaps bytes in 32-bit word
static Ipp32u SwapBytes_32u( Ipp32u x )
{
    return ( ( x & 0x000000FF ) << 24 ) |
            ( ( x & 0x0000FF00 ) << 8 ) |
            ( ( x & 0x00FF0000 ) >> 8 ) |
            ( ( x & 0xFF000000 ) >> 24 );
}

// Extracts low 32-bit dword of a 64-bit qword
static Ipp32u ExtractLow_64u32u( Ipp64u x )
{
    return (Ipp32u)x;
}

// Extracts high 32-bit dword of a 64-bit qword
static Ipp32u ExtractHigh_64u32u( Ipp64u x )
{
    return (Ipp32u)( x >> 32 );
}

// Returns the zero-based position of the most significant bit in a 32-bit dword
static Ipp32u BitScanReverse_32u( Ipp32u x )
{
    Ipp32u n = (Ipp32u)(-1);
    while( x != 0 ) {
        x >>= 1;
        n++;
    }
    return n;
}

// Carries out addition with carry.
// After the addition carry is updated appropriately.
static Ipp8u AddWithCarry_8u( Ipp8u a, Ipp8u b, Ipp8u* pCarry )
{
    Ipp8u result = a + b + *pCarry;
    *pCarry = (Ipp8u)( result < a );
    return result;
}

// Carries out addition with carry.
// After the addition carry is updated appropriately.
static Ipp64u AddWithCarry_64u( Ipp64u a, Ipp64u b, Ipp8u* pCarry )
{
    Ipp64u result = a + b + (Ipp64u)(*pCarry);
    *pCarry = (Ipp8u)( result < a );
    return result;
}


IppStatus ippiCABACEncodeBinOwn_H264(
    Ipp32u ctxIdx,
    Ipp32u code,
    IppvcCABACState* pCabacState_)
{
    IppvcCABACState_internal* pCabacState = (IppvcCABACState_internal *)pCabacState_;
    {
        Ipp32u* pBitStream = pCabacState->pBitStream;
        Ipp8u* pBitStreamCopy = (Ipp8u*)pBitStream;

        Ipp32u stateIdx = pCabacState->contexts[ctxIdx];
        Ipp32u codIRange = pCabacState->lcodIRange;
        Ipp32u codIOffset = pCabacState->lcodIOffset;
        Ipp32u codIRangeLPS = h264_cabac_rangeTabLPS[stateIdx][(codIRange >> 6) & 0x3];

        if( code != stateIdx >> 6 ) {
            // Encoding LPS symbol
            codIOffset += codIRange - codIRangeLPS;
            codIRange = codIRangeLPS;
        } else {
            // Encoding MPS symbol
            codIRange -= codIRangeLPS;
        }

        {
            Ipp32u nBitsVacant = pCabacState->nBitsVacant;
            Ipp32u nBitCount = 8 - BitScanReverse_32u( codIRange );
            Ipp32u nBitsVacantExt = 32 + nBitsVacant - nBitCount;
            codIOffset <<= nBitCount;
            codIRange <<= nBitCount;

            {
                Ipp64u uBitString = codIOffset >> 10;

                Ipp32u uBuffer = pCabacState->nRegister;
                Ipp64u uBufferExt = (Ipp64u)uBuffer << 32;
                Ipp8u bCarry = 0;

                uBufferExt = AddWithCarry_64u( uBufferExt, uBitString << nBitsVacantExt, &bCarry );
                uBuffer = ExtractHigh_64u32u( uBufferExt );
                *pBitStream = SwapBytes_32u( ExtractHigh_64u32u( uBufferExt ) );

                while( bCarry ) {
                    pBitStreamCopy--;
                    *pBitStreamCopy = AddWithCarry_8u( *pBitStreamCopy, 0, &bCarry );
                }

                if( nBitsVacantExt < 32 ) {
                    uBuffer = ExtractLow_64u32u( uBufferExt );
                    pBitStream++;
                    if( pBitStream >= pCabacState->pBitStreamEnd )
                        return ippStsNullPtrErr; //ippStsH264BufferFullErr;
                }
                pCabacState->contexts[ctxIdx] = h264_cabac_transTbl[code][stateIdx];

                pCabacState->lcodIRange = codIRange;
                pCabacState->lcodIOffset = codIOffset & 0x3FF;

                pCabacState->nBitsVacant = nBitsVacantExt % 32;
                pCabacState->nRegister = uBuffer;
                pCabacState->pBitStream = pBitStream;
            }
        }
        return ippStsNoErr;
    }
}

IppStatus ippiCABACEncodeBinBypassOwn_H264(
    Ipp32u code,
    IppvcCABACState* pCabacState_)
{
    IppvcCABACState_internal* pCabacState = (IppvcCABACState_internal *)pCabacState_;
    {
        Ipp32u* pBitStream = pCabacState->pBitStream;
        Ipp8u* pBitStreamCopy = (Ipp8u*)pBitStream;

        Ipp32u codIRange = pCabacState->lcodIRange;
        Ipp32u codIOffset = pCabacState->lcodIOffset;

        if( code == 1 ) {
            codIOffset += codIOffset + codIRange;
        } else {
            codIOffset += codIOffset;
        }

        {
            Ipp32u nBitsVacant = pCabacState->nBitsVacant;
            Ipp32u nBitsVacantExt = 31 + nBitsVacant;

            {
                Ipp64u uBitString = codIOffset >> 10;

                Ipp32u uBuffer = pCabacState->nRegister;
                Ipp64u uBufferExt = (Ipp64u)uBuffer << 32;
                Ipp8u bCarry = 0;

                uBufferExt = AddWithCarry_64u( uBufferExt, uBitString << nBitsVacantExt, &bCarry );
                uBuffer = ExtractHigh_64u32u( uBufferExt );
                *pBitStream = SwapBytes_32u( ExtractHigh_64u32u( uBufferExt ) );

                while( bCarry ) {
                    pBitStreamCopy--;
                    *pBitStreamCopy = AddWithCarry_8u( *pBitStreamCopy, 0, &bCarry );
                }

                if( nBitsVacantExt < 32 ) {
                    uBuffer = ExtractLow_64u32u( uBufferExt );
                    pBitStream++;
                    if( pBitStream >= pCabacState->pBitStreamEnd )
                        return ippStsNullPtrErr; //ippStsH264BufferFullErr;
                }

                pCabacState->lcodIRange = codIRange;
                pCabacState->lcodIOffset = codIOffset & 0x3FF;

                pCabacState->nBitsVacant = nBitsVacantExt % 32;
                pCabacState->nRegister = uBuffer;
                pCabacState->pBitStream = pBitStream;
            }
        }

        return ippStsNoErr;
    }
}

#if defined WIN32

inline Ipp32s IPP_INT_PTR( const void* ptr )  {
    union { void* Ptr; Ipp32s Int; } dd;
    dd.Ptr = (void *)ptr;
    return dd.Int;
}

inline Ipp32u IPP_UINT_PTR( const void* ptr )  {
    union {void* Ptr; Ipp32u Int; } dd;
    dd.Ptr = (void*)ptr;
    return dd.Int;
}

#elif defined WIN64

inline Ipp64s IPP_INT_PTR( const void* ptr )  {
    union { void* Ptr; Ipp64s Int; } dd;
    dd.Ptr = (void*)ptr;
    return dd.Int;
}

inline Ipp64u IPP_UINT_PTR( const void* ptr )  {
    union { void* Ptr; Ipp64u Int; } dd;
    dd.Ptr = (void*)ptr;
    return dd.Int;
}

#else

    #define IPP_INT_PTR( ptr )  ( (long)(ptr) )
    #define IPP_UINT_PTR( ptr ) ( (unsigned long)(ptr) )

#endif

#define IPP_ALIGN_TYPE(type, align) ((align)/sizeof(type)-1)
#define IPP_BYTES_TO_ALIGN(ptr, align) ((-(IPP_INT_PTR(ptr)&((align)-1)))&((align)-1))
#define IPP_ALIGNED_PTR(ptr, align) (void*)( (unsigned char*)(ptr) + (IPP_BYTES_TO_ALIGN( ptr, align )) )

void* ippAlignPtr(void * ptr, int alignBytes)
{
    return IPP_ALIGNED_PTR( ptr , alignBytes );
}

IppStatus ippiCABACTerminateSliceOwn_H264(
    Ipp32u* pBitStreamBytes,
    IppvcCABACState* pCabacState_)
{
    IppvcCABACState_internal* pCabacState = (IppvcCABACState_internal *)pCabacState_;
    {
        Ipp32u* pBitStream = pCabacState->pBitStream;

        Ipp32u codIOffset = pCabacState->lcodIOffset;


        {
            Ipp32u nBitsVacant = pCabacState->nBitsVacant;
            Ipp32u nBitsVacantExt = 29 + nBitsVacant;

            Ipp64u uBitString = ( codIOffset >> 7 ) | 1;

            Ipp32u uBuffer = pCabacState->nRegister;
            Ipp64u uBufferExt = (Ipp64u)uBuffer << 32;
            Ipp8u bCarry = 0;

            uBufferExt = AddWithCarry_64u( uBufferExt, uBitString << nBitsVacantExt, &bCarry );
            *pBitStream = SwapBytes_32u( ExtractHigh_64u32u( uBufferExt ) );
            if( nBitsVacantExt < 32 ) {
                if( pBitStream + 1 < pCabacState->pBitStreamEnd ) {
                    *(pBitStream + 1) = SwapBytes_32u( ExtractLow_64u32u( uBufferExt ) );
                } else
                    return ippStsMemAllocErr;
            }
            *pBitStreamBytes = ( 64 - nBitsVacantExt + 7 ) / 8 +
                (IPP_UINT_PTR( pBitStream ) - IPP_UINT_PTR( pCabacState->pBitStreamStart ) );

            pCabacState->lcodIRange = 0;
            pCabacState->lcodIOffset = 0;

            pCabacState->nBitsVacant = 0;
            pCabacState->nRegister = 0;
            pCabacState->pBitStream = 0;
            pCabacState->pBitStreamStart = 0;
            pCabacState->pBitStreamEnd = 0;
        }
        return ippStsNoErr;
    }
}

// See H.264 standard for function Clip3
static Ipp32s Clip3( Ipp32s min, Ipp32s max, Ipp32s value )
{
    if( value < min ) {
        return min;
    } else if( value > max ) {
        return max;
    } else {
        return value;
    }
}

static void AlignBitStreamWithOnes(
        Ipp8u* pBitStream,
        Ipp32u uBitStreamOffsetBits)
{
    if( uBitStreamOffsetBits % 8 != 0  ) {
        pBitStream[uBitStreamOffsetBits / 8] |= (0xFFU >> (uBitStreamOffsetBits % 8) );
    }
}

static void SetContext_H264(
        Ipp8u* pContext,
        Ipp16s m,
        Ipp16s n,
        Ipp32s SliceQPy)
{
    Ipp8u preCtxState = (Ipp8u)Clip3( 1, 126, ( ( m * SliceQPy ) >> 4 ) + n );
    if ( preCtxState <= 63 ) {
        *pContext = 63 - preCtxState; // MPS = 0
    } else {
        *pContext = ( preCtxState - 64 ) | ( 1 << 6 ); // MPS = 1
    }
}

static void InitIntraContext_H264(
    IppvcCABACState_internal* pCabacState,
    Ipp32s          SliceQPy)
{

    Ipp32s i;

    // See subclause 9.3.1.1 of H.264 standard
    SliceQPy = Clip3( 0, 51, SliceQPy );

    // Initialize context(s) for mb_type (SI & I slices)
    for (i = 0;i <= 10;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_0_10[i - 0].m,
            h264_cabac_M_and_N_for_ctxIdx_0_10[i - 0].n,
            SliceQPy );
    };

    // Initialize context(s) for mb_qp_delta &
    // intra_chroma_pred_mode & prev_intra4x4_pred_mode_flag &
    // rem_intra4x4_pred_mode
    for (i = 60;i <= 69;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_60_69[i - 60].m,
            h264_cabac_M_and_N_for_ctxIdx_60_69[i - 60].n,
            SliceQPy );
    };

    // Initialize context(s) for mb_field_decoding_flag &
    // coded_block_pattern(luma) & coded_block_pattern(chroma) &
    // coded_block_flag (SI & I slices)
    for (i = 70;i <= 104;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_70_104_intra[i - 70].m,
            h264_cabac_M_and_N_for_ctxIdx_70_104_intra[i - 70].n,
            SliceQPy );
    };

    // Initalize context(s) for significant_coeff_flag[] (frame coded)
    for (i = 105;i <= 165;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_105_165_intra[i - 105].m,
            h264_cabac_M_and_N_for_ctxIdx_105_165_intra[i - 105].n,
            SliceQPy );
    };

    // Initalize context(s) for last_significant_coeff_flag[] (frame coded)
    for (i = 166;i <= 226;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_166_226_intra[i - 166].m,
            h264_cabac_M_and_N_for_ctxIdx_166_226_intra[i - 166].n,
            SliceQPy );
    };

    // Initalize context(s) for coeff_abs_level_minus1[]
    for (i = 227;i <= 275;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_227_275_intra[i - 227].m,
            h264_cabac_M_and_N_for_ctxIdx_227_275_intra[i - 227].n,
            SliceQPy );
    };

    // ctxIdx equal to 276 is associated the end_of_slice_flag
    // Initial values associated with ctxIdx equal to 276
    // are specified to be stateIdx = 63 and valMPS = 0
    pCabacState->contexts[276] = 63;

    // Initalize context(s) for significant_coeff_flag[] (field coded)
    for (i = 277;i <= 337;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_277_337_intra[i - 277].m,
            h264_cabac_M_and_N_for_ctxIdx_277_337_intra[i - 277].n,
            SliceQPy );
    };

    // Initalize context(s) for last_significant_coeff_flag[] (field coded)
    for (i = 338;i <= 398;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_338_398_intra[i - 338].m,
            h264_cabac_M_and_N_for_ctxIdx_338_398_intra[i - 338].n,
            SliceQPy );
    };

    for (i = 399;i <= 401;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_399_401_intra[i - 399].m,
            h264_cabac_M_and_N_for_ctxIdx_399_401_intra[i - 399].n,
            SliceQPy
        );
    };
    for (i = 402;i <= 459;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_402_459_intra[i - 402].m,
            h264_cabac_M_and_N_for_ctxIdx_402_459_intra[i - 402].n,
            SliceQPy
        );
    };

    for (i = BASE_MODE_FLAG_OFFSET; i <= BASE_MODE_FLAG_OFFSET + 2; i += 1)
    {
        SetContext_H264(pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_1024_1026_intra[i - BASE_MODE_FLAG_OFFSET].m,
            h264_cabac_M_and_N_for_ctxIdx_1024_1026_intra[i - BASE_MODE_FLAG_OFFSET].n,
            SliceQPy);
    }
}

static void InitInterContext_H264(
    IppvcCABACState_internal* pCabacState,
    Ipp32s          SliceQPy,
    Ipp32s          cabacInitIdc)
{
    Ipp32s i;

    // See subclause 9.3.1.1 of H.264 standard
    SliceQPy = Clip3( 0, 51, SliceQPy );

    for (i = 11;i <= 23;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_11_23[i - 11][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_11_23[i - 11][cabacInitIdc].n,
            SliceQPy );
    };

    // Initialize context(s) for mb_skip_flag & mb_type (B slices)
    // & sub_mb_pred (B slices)
    for (i = 24;i <= 39;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_24_39[i - 24][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_24_39[i - 24][cabacInitIdc].n,
            SliceQPy );
    };

    // Initialize context(s) for mvd_10 & mvd_11
    for (i = 40;i <= 53;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_40_53[i - 40][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_40_53[i - 40][cabacInitIdc].n,
            SliceQPy );
    };

    // Initialize context(s) for ref_idx_10 & ref_idx_11
    for (i = 54;i <= 59;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_54_59[i - 54][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_54_59[i - 54][cabacInitIdc].n,
            SliceQPy );
    };

    // Initialize context(s) for mb_qp_delta &
    // intra_chroma_pred_mode & prev_intra4x4_pred_mode_flag &
    // rem_intra4x4_pred_mode
    for (i = 60;i <= 69;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_60_69[i - 60].m,
            h264_cabac_M_and_N_for_ctxIdx_60_69[i - 60].n,
            SliceQPy );
    };

    // Initalize context(s) for mb_field_decoding_flag &
    // coded_block_pattern(luma) & coded_block_pattern(chroma) &
    // coded_block_flag (P, SP & B slices)
    for (i = 70;i <= 104;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_70_104_inter[i - 70][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_70_104_inter[i - 70][cabacInitIdc].n,
            SliceQPy );
    };

    // Initalize context(s) for significant_coeff_flag[] (frame coded)
    for (i = 105;i <= 165;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_105_165_inter[i - 105][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_105_165_inter[i - 105][cabacInitIdc].n,
            SliceQPy );
    }

    // Initalize context(s) for last_significant_coeff_flag[] (frame coded)
    for (i = 166;i <= 226;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_166_226_inter[i - 166][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_166_226_inter[i - 166][cabacInitIdc].n,
            SliceQPy );
    };

    // Initalize context(s) for coeff_abs_level_minus1[]
    for (i = 227;i <= 275;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_227_275_inter[i - 227][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_227_275_inter[i - 227][cabacInitIdc].n,
            SliceQPy );
    };

    // ctxIdx equal to 276 is associated the end_of_slice_flag
    // Initial values associated with ctxIdx equal to 276
    // are specified to be stateIdx = 63 and valMPS = 0
    pCabacState->contexts[276] = 63;

    // Initalize context(s) for significant_coeff_flag[] (field coded)
    for (i = 277;i <= 337;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_277_337_inter[i - 277][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_277_337_inter[i - 277][cabacInitIdc].n,
            SliceQPy );
    };

    // Initalize context(s) for last_significant_coeff_flag[] (field coded)
    for (i = 338;i <= 398;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_338_398_inter[i - 338][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_338_398_inter[i - 338][cabacInitIdc].n,
            SliceQPy );
    };

    for (i = 399;i <= 401;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_399_401_inter[i - 399][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_399_401_inter[i - 399][cabacInitIdc].n,
            SliceQPy );
    };
    for (i = 402;i <= 459;i += 1)
    {
        SetContext_H264( pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_402_459_inter[i - 402][cabacInitIdc].m,
            h264_cabac_M_and_N_for_ctxIdx_402_459_inter[i - 402][cabacInitIdc].n,
            SliceQPy );
    };

    for (i = BASE_MODE_FLAG_OFFSET; i <= BASE_MODE_FLAG_OFFSET + 2; i += 1)
    {
        SetContext_H264(pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_1024_1026_inter[i - BASE_MODE_FLAG_OFFSET].m,
            h264_cabac_M_and_N_for_ctxIdx_1024_1026_inter[i - BASE_MODE_FLAG_OFFSET].n,
            SliceQPy);
    }

    for (i = BASE_MODE_FLAG_OFFSET + 3; i <= BASE_MODE_FLAG_OFFSET + 6; i += 1)
    {
        SetContext_H264(pCabacState->contexts + i,
            h264_cabac_M_and_N_for_ctxIdx_1027_1030[i - BASE_MODE_FLAG_OFFSET - 3].m,
            h264_cabac_M_and_N_for_ctxIdx_1027_1030[i - BASE_MODE_FLAG_OFFSET - 3].n,
            SliceQPy);
    }
}

IppStatus ippiCABACGetSizeOwn_H264(
    Ipp32u* pSize)
{
    *pSize = sizeof(IppvcCABACState_internal);
    return ippStsNoErr;
}

IppStatus ippiCABACInitOwn_H264(
    IppvcCABACState* pCabacState_,
    Ipp8u*          pBitStream,
    Ipp32u          nBitStreamOffsetBits,
    Ipp32u          nBitStreamSize,
    Ipp32s          SliceQPy,
    Ipp32s          cabacInitIdc)
{
    IppvcCABACState_internal* pCabacState = (IppvcCABACState_internal *)pCabacState_;

    {
        Ipp32u nBitStreamOffsetBytes = ( nBitStreamOffsetBits + 7 ) / 8;
        Ipp8u* pBitStreamCurrentByte = pBitStream + nBitStreamOffsetBytes;
        pCabacState->lcodIOffset = 0;
        pCabacState->lcodIRange = 0x1FE;
        pCabacState->pBitStreamStart = pBitStream;
        pCabacState->pBitStreamEnd = (Ipp32u *)ippAlignPtr( pBitStream + nBitStreamSize - 4, 4 );
        pCabacState->nPreCabacBitOffset = nBitStreamOffsetBits;

        AlignBitStreamWithOnes( pBitStream, nBitStreamOffsetBits );

        switch( IPP_UINT_PTR( pBitStreamCurrentByte ) % 4 ) {
            case 0:
                pCabacState->pBitStream = (Ipp32u*)( pBitStreamCurrentByte - 4 );
                pCabacState->nBitsVacant = 1;
                pCabacState->nRegister = SwapBytes_32u( *( pCabacState->pBitStream ) );
                break;
            case 1:
                pCabacState->pBitStream = (Ipp32u*)( pBitStreamCurrentByte - 1 );
                pCabacState->nBitsVacant = 25;
                pCabacState->nRegister = SwapBytes_32u( *( pCabacState->pBitStream ) ) & 0xFF000000U;
                break;
            case 2:
                pCabacState->pBitStream = (Ipp32u*)( pBitStreamCurrentByte - 2 );
                pCabacState->nBitsVacant = 17;
                pCabacState->nRegister = SwapBytes_32u( *( pCabacState->pBitStream ) ) & 0xFFFF0000U;
                break;
            case 3:
                pCabacState->pBitStream = (Ipp32u*)( pBitStreamCurrentByte - 3 );
                pCabacState->nBitsVacant = 9;
                pCabacState->nRegister = SwapBytes_32u( *( pCabacState->pBitStream ) ) & 0xFFFFFF00U;
                break;
        }


        if( cabacInitIdc == -1 )
            InitIntraContext_H264( pCabacState, SliceQPy );
        else
            InitInterContext_H264( pCabacState, SliceQPy, cabacInitIdc );

        return ippStsNoErr;
    }
}

IppStatus ippiCABACInitAEEOwn_H264(
    IppvcCABACState* pCabacState_,
    Ipp8u*          pBitStream,
    Ipp32u          nBitStreamOffsetBits,
    Ipp32u          nBitStreamSize)
{
    IppvcCABACState_internal* pCabacState = (IppvcCABACState_internal *)pCabacState_;
    {
        Ipp32u nBitStreamOffsetBytes = ( nBitStreamOffsetBits + 7 ) / 8;
        Ipp8u* pBitStreamCurrentByte = pBitStream + nBitStreamOffsetBytes;
        pCabacState->lcodIOffset = 0;
        pCabacState->lcodIRange = 0x1FE;
        pCabacState->pBitStreamStart = pBitStream;
        pCabacState->pBitStreamEnd = (Ipp32u *)ippAlignPtr( pBitStream + nBitStreamSize - 4, 4 );
        pCabacState->nPreCabacBitOffset = nBitStreamOffsetBits;

        switch( IPP_UINT_PTR( pBitStreamCurrentByte ) % 4 ) {
            case 0:
                pCabacState->pBitStream = (Ipp32u*)( pBitStreamCurrentByte - 4 );
                pCabacState->nBitsVacant = 1;
                pCabacState->nRegister = SwapBytes_32u( *( pCabacState->pBitStream ) );
                break;
            case 1:
                pCabacState->pBitStream = (Ipp32u*)( pBitStreamCurrentByte - 1 );
                pCabacState->nBitsVacant = 25;
                pCabacState->nRegister = SwapBytes_32u( *( pCabacState->pBitStream ) ) & 0xFF000000U;
                break;
            case 2:
                pCabacState->pBitStream = (Ipp32u*)( pBitStreamCurrentByte - 2 );
                pCabacState->nBitsVacant = 17;
                pCabacState->nRegister = SwapBytes_32u( *( pCabacState->pBitStream ) ) & 0xFFFF0000U;
                break;
            case 3:
                pCabacState->pBitStream = (Ipp32u*)( pBitStreamCurrentByte - 3 );
                pCabacState->nBitsVacant = 9;
                pCabacState->nRegister = SwapBytes_32u( *( pCabacState->pBitStream ) ) & 0xFFFFFF00U;
                break;
        }

        return ippStsNoErr;
    }
}

IppStatus ippiCABACInitAllocOwn_H264(
    IppvcCABACState** ppCabacState,
    Ipp8u*           pBitStream,
    Ipp32u           nBitStreamOffsetBits,
    Ipp32u           uBitStreamSize,
    Ipp32s           SliceQPy,
    Ipp32s           cabacInitIdc)
{
    IppvcCABACState* pCabacState = NULL;

    pCabacState = (IppvcCABACState *)ippMalloc( sizeof( IppvcCABACState_internal ) );
    if( !pCabacState )
        return ippStsNoMemErr;

    IppStatus status = ippStsNoErr;
    status = ippiCABACInit_H264( (IppvcCABACState *)pCabacState,
        pBitStream,
        nBitStreamOffsetBits,
        uBitStreamSize,
        SliceQPy,
        cabacInitIdc );
    if( status != ippStsNoErr ) {
        ippFree( pCabacState );
        return status;
    }

    *ppCabacState = pCabacState;
    return ippStsNoErr;
}

IppStatus ippiCABACFreeOwn_H264(
    IppvcCABACState* pCabacState)
{
    ippFree( pCabacState );
    return ippStsNoErr;
}

IppStatus ippiCABACEncodeBins_H264(
    Ipp32u ctxIdx,
    Ipp32u bitString,
    Ipp32u length,
    IppvcCABACState* pCabacState,
    Ipp32u& numBins )
{
    IppStatus status = ippStsNoErr;

    numBins += length;

    while( length > 0 ) {
        length--;
        {
            Ipp32u code = ( bitString >> length ) & 1;
            status = ippiCABACEncodeBin_H264( ctxIdx, code, pCabacState );
            if( status != ippStsNoErr )
                return status;
        }
    }
    return ippStsNoErr;
}

IppStatus ippiCABACEncodeExG0Symbol_H264(
    Ipp32u code,
    IppvcCABACState* pCabacState,
    Ipp32u& numBins)
{
    Ipp32u log2ex = 0;
    IppStatus status = ippStsNoErr;
    for (;;)
    {
        if( code>= ( 1U<<log2ex ) ) {
            status = ippiCABACEncodeBinBypass_H264( 1, pCabacState );
            if( status != ippStsNoErr )
                return status;
            code -= ( 1U<<log2ex );
            log2ex++;
            numBins++;
        } else {
            status = ippiCABACEncodeBinBypass_H264( 0, pCabacState );
            if( status != ippStsNoErr )
                return status;
            numBins++;
            while( log2ex-- ) {
                status = ippiCABACEncodeBinBypass_H264( ( code >> log2ex ) & 1, pCabacState );
                if( status != ippStsNoErr )
                    return status;
                numBins++;
            }
            return ippStsNoErr;
        }
    }
}

IppStatus ippiCABACEncodeResidualLevel_H264(
    Ipp32u ctxIdx,
    Ipp32u code,
    IppvcCABACState* pCabacState,
    Ipp32u& numBins)
{
    /* 2^(i+1)-2 except last=2^(i+1)-1 */
    static Ipp32u c[14] = {0,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16383};

    if( code == 0 ) {
        numBins++;
        return ippiCABACEncodeBin_H264( ctxIdx, 0, pCabacState );
    } else {
        if( code < 13 ) {
            ippiCABACEncodeBins_H264( ctxIdx, c[code], code + 1, pCabacState, numBins );
        } else {
            ippiCABACEncodeBins_H264( ctxIdx, c[13], 13, pCabacState, numBins );
            ippiCABACEncodeExG0Symbol_H264( code - 13, pCabacState, numBins );
        }
    }
    return ippStsNoErr;
}

IppStatus ippiCABACGetContextsWrap_H264(
    Ipp8u*           pContexts,
    Ipp32u           from,
    Ipp32u           num,
    IppvcCABACState* pCabacState)
{
#ifdef H264_OWN_CABAC_IMPL
    if (pCabacState == 0)
        return ippStsNullPtrErr;
    if (pContexts == 0)
        return ippStsNullPtrErr;
    if (from + num > CABAC_CONTEXT_ARRAY_LEN)
        return ippStsOutOfRangeErr;

    IppvcCABACState_internal* internalState = (IppvcCABACState_internal *)pCabacState;
    MFX_INTERNAL_CPY(pContexts, internalState->contexts + from, num);
    return ippStsNoErr;
#else // H264_OWN_CABAC_IMPL
    if(from + num <= 460)
        return ippiCABACGetContexts_H264(pCabacState, from, pContexts, num);

    if (pCabacState == 0)
        return ippStsNullPtrErr;
    if (pContexts == 0)
        return ippStsNullPtrErr;
    if (from + num > CABAC_CONTEXT_ARRAY_LEN)
        return ippStsOutOfRangeErr;

    if(from < 460) {
        ippiCABACGetContexts_H264(pCabacState, from, pContexts, 460-from);
        num -= 460-from;
        pContexts += 460-from;
        from = 460;
    }

    // hacking to avoid 460 contents limitation
    Ipp32u sizeOfCabacState = 0;
    ippiCABACGetSize_H264(&sizeOfCabacState);
    Ipp8u* extra_contexts = (Ipp8u*)pCabacState + sizeOfCabacState;
    MFX_INTERNAL_CPY(pContexts, extra_contexts + (from-460), num);
    return ippStsNoErr;
#endif // H264_OWN_CABAC_IMPL
}
typedef struct ___IppvcCABACState {
    Ipp32u* pBitStream;
    Ipp8u* pBitStreamStart;
    Ipp32u* pBitStreamEnd;

    Ipp32u lcodIOffset;
    Ipp32u lcodIRange;
    Ipp32u nBitsVacant;
    Ipp32u nRegister;
    Ipp32u nPreCabacBitOffset;

    Ipp8u contexts[460];
} __IppvcCABACState;
#define cabprintf(...)

Status H264BsReal_ResidualBlock_CABAC(
    const Ipp16s*   pResidualCoeffs,
    Ipp32u          nLastNonZeroCoeff,
    Ipp32u          ctxBlockCat,
    Ipp32u          bFrameBlock,
    H264BsBase*     bs,
    Ipp32s          idx_start,
    Ipp32s          idx_end)
{
    IppvcCABACState* pCabacState = ((H264BsReal_8u16s *)bs)->m_base.pCabacState;
    Ipp32s logNumC8x8 = ((H264BsReal_8u16s *)bs)->num8x8Cshift2;
    Ipp32u& numBins = ((H264BsReal_8u16s *)bs)->m_base.m_numBins;

    IppStatus status;
    Ipp32u maxNumCoeff = maxNumCoeffTable[ctxBlockCat] << logNumC8x8;
    Ipp32u ctxIdxOffset_SignificantCoeffFlag;
    Ipp32u ctxIdxOffset_LastSignificantCoeffFlag;
    Ipp32u ctxIdxOffset_CoeffAbsLevelMinus1 = 0;
    Ipp32u ctxIdxBlockCatOffset_SignificantCoeffFlag;
    Ipp32u ctxIdxBlockCatOffset_LastSignificantCoeffFlag;
    Ipp32u ctxIdxBlockCatOffset_CoeffAbsLevelMinus1;
    Ipp32u ctxIdxInc; // See Clause 9.3.3.1.3 of H.264 standard
    Ipp32u ctxIdx_SignificantCoeffFlag; // See Clause 9.3.3.1 of H.264 standard
    Ipp32u ctxIdx_LastSignificantCoeffFlag; // See Clause 9.3.3.1 of H.264 standard
    Ipp32s i;
    Ipp32u levelListIdx;

    Ipp32s numSigCoeff = 0;
    Ipp16s sigCoeff[64];

    if (ctxBlockCat == BLOCK_LUMA_64_LEVELS) {
        maxNumCoeff -= (60 - idx_end);
    } else {
        maxNumCoeff -= (15 - idx_end);
    }

    // There is no need to encode the encode the existence of the last significant coefficient in the coefficient map
    if (nLastNonZeroCoeff == maxNumCoeff - 1)
        maxNumCoeff--;
    else if (nLastNonZeroCoeff >= maxNumCoeff)
        return UMC_ERR_INVALID_PARAMS;

    switch (ctxBlockCat)
    {
        case 0:
        case 1:
        case 2:
        case 4:
        {
            ctxIdxOffset_SignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat01234_FrameCodedBlock_SignificantCoeffFlag :
                ctxIdxOffset_BlockCat01234_FieldCodedBlock_SignificantCoeffFlag;
            ctxIdxBlockCatOffset_SignificantCoeffFlag = ctxIdxBlockCatOffset_SignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_LastSignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat01234_FrameCodedBlock_LastSignificantCoeffFlag :
                ctxIdxOffset_BlockCat01234_FieldCodedBlock_LastSignificantCoeffFlag;
            ctxIdxBlockCatOffset_LastSignificantCoeffFlag = ctxIdxBlockCatOffset_LastSignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_CoeffAbsLevelMinus1 = ctxIdxOffset_BlockCat01234_CoeffAbsLevelMinus1;

            for( levelListIdx = idx_start; levelListIdx < maxNumCoeff; levelListIdx++ ) {
                ctxIdxInc = levelListIdx;
                ctxIdx_SignificantCoeffFlag = ctxIdxOffset_SignificantCoeffFlag + ctxIdxBlockCatOffset_SignificantCoeffFlag + ctxIdxInc;
                ctxIdx_LastSignificantCoeffFlag = ctxIdxOffset_LastSignificantCoeffFlag + ctxIdxBlockCatOffset_LastSignificantCoeffFlag + ctxIdxInc;

                cabprintf("range = %d\n",((__IppvcCABACState*)(pCabacState))->lcodIRange);
                status = ippiCABACEncodeBin_H264(ctxIdx_SignificantCoeffFlag, pResidualCoeffs[levelListIdx] != 0, pCabacState);
                if( status != ippStsNoErr )
                    goto errorExit;
                numBins++;

                if( pResidualCoeffs[levelListIdx] != 0 ) {
                    sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];
                    cabprintf("range = %d\n",((__IppvcCABACState*)(pCabacState))->lcodIRange);
                    status = ippiCABACEncodeBin_H264( ctxIdx_LastSignificantCoeffFlag, levelListIdx == nLastNonZeroCoeff, pCabacState );
                    if( status != ippStsNoErr )
                        goto errorExit;
                    numBins++;
                    if( levelListIdx == nLastNonZeroCoeff )
                        break;
                }
            }

            if (levelListIdx == maxNumCoeff && pResidualCoeffs[levelListIdx] != 0)
                sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];

            break;
        }
        case 3:
        {
            ctxIdxOffset_SignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat01234_FrameCodedBlock_SignificantCoeffFlag :
                ctxIdxOffset_BlockCat01234_FieldCodedBlock_SignificantCoeffFlag;
            ctxIdxBlockCatOffset_SignificantCoeffFlag = ctxIdxBlockCatOffset_SignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_LastSignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat01234_FrameCodedBlock_LastSignificantCoeffFlag :
                ctxIdxOffset_BlockCat01234_FieldCodedBlock_LastSignificantCoeffFlag;
            ctxIdxBlockCatOffset_LastSignificantCoeffFlag = ctxIdxBlockCatOffset_LastSignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_CoeffAbsLevelMinus1 = ctxIdxOffset_BlockCat01234_CoeffAbsLevelMinus1;

            for( levelListIdx = idx_start; levelListIdx < maxNumCoeff; levelListIdx++ ) {
                ctxIdxInc = Min_32u( levelListIdx >> logNumC8x8, 2 );

                ctxIdx_SignificantCoeffFlag = ctxIdxOffset_SignificantCoeffFlag + ctxIdxBlockCatOffset_SignificantCoeffFlag + ctxIdxInc;
                ctxIdx_LastSignificantCoeffFlag = ctxIdxOffset_LastSignificantCoeffFlag + ctxIdxBlockCatOffset_LastSignificantCoeffFlag + ctxIdxInc;

                cabprintf("range = %d\n",((__IppvcCABACState*)(pCabacState))->lcodIRange);
                status = ippiCABACEncodeBin_H264(
                    ctxIdx_SignificantCoeffFlag,
                    pResidualCoeffs[levelListIdx] != 0,
                    pCabacState);

                if( status != ippStsNoErr )
                    goto errorExit;
                numBins++;

                if( pResidualCoeffs[levelListIdx] != 0 ) {
                    sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];
                    cabprintf("range = %d\n",((__IppvcCABACState*)(pCabacState))->lcodIRange);
                    status = ippiCABACEncodeBin_H264(
                        ctxIdx_LastSignificantCoeffFlag,
                        levelListIdx == nLastNonZeroCoeff,
                        pCabacState);

                    if (status != ippStsNoErr)
                        goto errorExit;
                    numBins++;
                    if (levelListIdx == nLastNonZeroCoeff)
                        break;
                }
            }

            if (levelListIdx == maxNumCoeff && pResidualCoeffs[levelListIdx] != 0)
                sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];

            break;
        }
        case 5:
        {
            ctxIdxOffset_SignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat5_FrameCodedBlock_SignificantCoeffFlag :
                ctxIdxOffset_BlockCat5_FieldCodedBlock_SignificantCoeffFlag;
            ctxIdxBlockCatOffset_SignificantCoeffFlag = ctxIdxBlockCatOffset_SignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_LastSignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat5_FrameCodedBlock_LastSignificantCoeffFlag :
                ctxIdxOffset_BlockCat5_FieldCodedBlock_LastSignificantCoeffFlag;
            ctxIdxBlockCatOffset_LastSignificantCoeffFlag = ctxIdxBlockCatOffset_LastSignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_CoeffAbsLevelMinus1 = ctxIdxOffset_BlockCat5_CoeffAbsLevelMinus1;

            for( levelListIdx = idx_start; levelListIdx < maxNumCoeff; levelListIdx++ ) {
                ctxIdxInc = bFrameBlock ?
                    ctxIdxInc_BlockCat5913_FrameCodedBlock_SignificantCoeffFlag[levelListIdx] :
                    ctxIdxInc_BlockCat5913_FieldCodedBlock_SignificantCoeffFlag[levelListIdx];

                ctxIdx_SignificantCoeffFlag = ctxIdxOffset_SignificantCoeffFlag + ctxIdxBlockCatOffset_SignificantCoeffFlag + ctxIdxInc;

                ctxIdxInc = ctxIdxInc_BlockCat5913_LastSignificantCoeffFlag[levelListIdx];
                ctxIdx_LastSignificantCoeffFlag = ctxIdxOffset_LastSignificantCoeffFlag + ctxIdxBlockCatOffset_LastSignificantCoeffFlag + ctxIdxInc;

                cabprintf("range = %d\n",((__IppvcCABACState*)(pCabacState))->lcodIRange);
                status = ippiCABACEncodeBin_H264( ctxIdx_SignificantCoeffFlag, pResidualCoeffs[levelListIdx] != 0, pCabacState );
                if( status != ippStsNoErr )
                    goto errorExit;
                numBins++;

                if( pResidualCoeffs[levelListIdx] != 0 ) {
                    sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];
                    cabprintf("range = %d\n",((__IppvcCABACState*)(pCabacState))->lcodIRange);
                    status = ippiCABACEncodeBin_H264(ctxIdx_LastSignificantCoeffFlag, levelListIdx == nLastNonZeroCoeff, pCabacState );
                    if( status != ippStsNoErr )
                        goto errorExit;
                    numBins++;
                    if( levelListIdx == nLastNonZeroCoeff )
                        break;
                }
            }

            if (levelListIdx == maxNumCoeff && pResidualCoeffs[levelListIdx] != 0)
                sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];

            break;
        }
    }

    { // GCC will give compiler errors on variables initialization
        const Ipp32u* ctx_trans0 = ctx_id_trans0;
        const Ipp32u* ctx_trans1 = ctxBlockCat == BLOCK_CHROMA_DC_LEVELS ? ctx_id_trans13 : ctx_id_trans1;

        Ipp32u ctx_id = 0;
        ctxIdxBlockCatOffset_CoeffAbsLevelMinus1 = ctxIdxBlockCatOffset_CoeffAbsLevelMinus1_Table[ctxBlockCat];

        for (i = numSigCoeff - 1; i >= 0; i--)
        {
            Ipp32s coeff = (Ipp32s)sigCoeff[i];
            Ipp32u sign = coeff >> 31; // sign = coeff > 0 ? 0 : 0xffffffff;
            Ipp32u level = (coeff + (~sign)) ^ sign; // level = abs(coeff) - 1

            if (level)
            {
                Ipp32u ctx = ctxIdxOffset_CoeffAbsLevelMinus1 + ctxIdxBlockCatOffset_CoeffAbsLevelMinus1 + ctx_neq1p1[ctx_id];
                cabprintf("range = %d\n",((__IppvcCABACState*)(pCabacState))->lcodIRange);
                ippiCABACEncodeBin_H264(ctx, 1, pCabacState);
                numBins++;

                ctx = ctxIdxOffset_CoeffAbsLevelMinus1 + ctxIdxBlockCatOffset_CoeffAbsLevelMinus1 + ctx_ngt1[ctx_id];
                cabprintf("range = %d\n",((__IppvcCABACState*)(pCabacState))->lcodIRange);
                ippiCABACEncodeResidualLevel_H264(ctx, --level, pCabacState, numBins);
                ctx_id = ctx_trans1[ctx_id];
            }
            else
            {
                Ipp32u ctx = ctxIdxOffset_CoeffAbsLevelMinus1 + ctxIdxBlockCatOffset_CoeffAbsLevelMinus1 + ctx_neq1p1[ctx_id];
                cabprintf("range = %d\n",((__IppvcCABACState*)(pCabacState))->lcodIRange);
                ippiCABACEncodeBin_H264(ctx, 0, pCabacState);
                numBins++;
                ctx_id = ctx_trans0 [ctx_id];
            }

            ippiCABACEncodeBinBypass_H264(sign & 1, pCabacState);
            numBins++;
        }
    }
    return ippStsNoErr;

errorExit:
    return status;
}

Status H264BsFake_ResidualBlock_CABAC(
    const Ipp16s*   pResidualCoeffs,
    Ipp32u          nLastNonZeroCoeff,
    Ipp32u          ctxBlockCat,
    Ipp32u          bFrameBlock,
    H264BsBase*     state,
    Ipp32s          idx_start,
    Ipp32s          idx_end)
{
    H264BsFake_8u16s* bs = (H264BsFake_8u16s *)state;
    Ipp32s logNumC8x8 = ((H264BsFake_8u16s *)bs)->num8x8Cshift2;

    Ipp32u maxNumCoeff = maxNumCoeffTable[ctxBlockCat] << logNumC8x8;
    Ipp32u ctxIdxOffset_SignificantCoeffFlag;
    Ipp32u ctxIdxOffset_LastSignificantCoeffFlag;
    Ipp32u ctxIdxOffset_CoeffAbsLevelMinus1 = 0;
    Ipp32u ctxIdxBlockCatOffset_SignificantCoeffFlag;
    Ipp32u ctxIdxBlockCatOffset_LastSignificantCoeffFlag;
    Ipp32u ctxIdxBlockCatOffset_CoeffAbsLevelMinus1;
    Ipp32u ctxIdxInc; // See Clause 9.3.3.1.3 of H.264 standard
    Ipp32u ctxIdx_SignificantCoeffFlag; // See Clause 9.3.3.1 of H.264 standard
    Ipp32u ctxIdx_LastSignificantCoeffFlag; // See Clause 9.3.3.1 of H.264 standard
    Ipp32s i;
    Ipp32u levelListIdx;

    Ipp32s numSigCoeff = 0;
    Ipp16s sigCoeff[64];

    if (ctxBlockCat == BLOCK_LUMA_64_LEVELS) {
        maxNumCoeff -= (60 - idx_end);
    } else {
        maxNumCoeff -= (15 - idx_end);
    }

    // There is no need to encode the encode the existence of the last significant coefficient in the coefficient map
    if (nLastNonZeroCoeff == maxNumCoeff - 1)
        maxNumCoeff--;
    else if (nLastNonZeroCoeff >= maxNumCoeff)
        return UMC_ERR_INVALID_PARAMS;

    switch (ctxBlockCat)
    {
        case 0:
        case 1:
        case 2:
        case 4:
        {
            ctxIdxOffset_SignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat01234_FrameCodedBlock_SignificantCoeffFlag :
                ctxIdxOffset_BlockCat01234_FieldCodedBlock_SignificantCoeffFlag;
            ctxIdxBlockCatOffset_SignificantCoeffFlag = ctxIdxBlockCatOffset_SignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_LastSignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat01234_FrameCodedBlock_LastSignificantCoeffFlag :
                ctxIdxOffset_BlockCat01234_FieldCodedBlock_LastSignificantCoeffFlag;
            ctxIdxBlockCatOffset_LastSignificantCoeffFlag = ctxIdxBlockCatOffset_LastSignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_CoeffAbsLevelMinus1 = ctxIdxOffset_BlockCat01234_CoeffAbsLevelMinus1;

            for( levelListIdx = idx_start; levelListIdx < maxNumCoeff; levelListIdx++ ) {
                ctxIdxInc = levelListIdx;
                ctxIdx_SignificantCoeffFlag = ctxIdxOffset_SignificantCoeffFlag + ctxIdxBlockCatOffset_SignificantCoeffFlag + ctxIdxInc;
                ctxIdx_LastSignificantCoeffFlag = ctxIdxOffset_LastSignificantCoeffFlag + ctxIdxBlockCatOffset_LastSignificantCoeffFlag + ctxIdxInc;

                H264BsFake_EncodeSingleBin_CABAC_8u16s(bs, ctxIdx_SignificantCoeffFlag, pResidualCoeffs[levelListIdx] != 0);

                if( pResidualCoeffs[levelListIdx] != 0 ) {
                    sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];
                    H264BsFake_EncodeSingleBin_CABAC_8u16s(bs, ctxIdx_LastSignificantCoeffFlag, levelListIdx == nLastNonZeroCoeff);

                    if( levelListIdx == nLastNonZeroCoeff )
                        break;
                }
            }

            if (levelListIdx == maxNumCoeff && pResidualCoeffs[levelListIdx] != 0)
                sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];

            break;
        }
        case 3:
        {
            ctxIdxOffset_SignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat01234_FrameCodedBlock_SignificantCoeffFlag :
                ctxIdxOffset_BlockCat01234_FieldCodedBlock_SignificantCoeffFlag;
            ctxIdxBlockCatOffset_SignificantCoeffFlag = ctxIdxBlockCatOffset_SignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_LastSignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat01234_FrameCodedBlock_LastSignificantCoeffFlag :
                ctxIdxOffset_BlockCat01234_FieldCodedBlock_LastSignificantCoeffFlag;
            ctxIdxBlockCatOffset_LastSignificantCoeffFlag = ctxIdxBlockCatOffset_LastSignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_CoeffAbsLevelMinus1 = ctxIdxOffset_BlockCat01234_CoeffAbsLevelMinus1;

            for( levelListIdx = idx_start; levelListIdx < maxNumCoeff; levelListIdx++ ) {
                ctxIdxInc = Min_32u( levelListIdx >> logNumC8x8, 2 );

                ctxIdx_SignificantCoeffFlag = ctxIdxOffset_SignificantCoeffFlag + ctxIdxBlockCatOffset_SignificantCoeffFlag + ctxIdxInc;
                ctxIdx_LastSignificantCoeffFlag = ctxIdxOffset_LastSignificantCoeffFlag + ctxIdxBlockCatOffset_LastSignificantCoeffFlag + ctxIdxInc;

                H264BsFake_EncodeSingleBin_CABAC_8u16s(bs, ctxIdx_SignificantCoeffFlag, pResidualCoeffs[levelListIdx] != 0);

                if( pResidualCoeffs[levelListIdx] != 0 )
                {
                    sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];
                    H264BsFake_EncodeSingleBin_CABAC_8u16s(bs, ctxIdx_LastSignificantCoeffFlag, levelListIdx == nLastNonZeroCoeff);

                    if( levelListIdx == nLastNonZeroCoeff )
                        break;
                }
            }

            if (levelListIdx == maxNumCoeff && pResidualCoeffs[levelListIdx] != 0)
                sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];

            break;
        }
        case 5:
        {
            ctxIdxOffset_SignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat5_FrameCodedBlock_SignificantCoeffFlag :
                ctxIdxOffset_BlockCat5_FieldCodedBlock_SignificantCoeffFlag;
            ctxIdxBlockCatOffset_SignificantCoeffFlag = ctxIdxBlockCatOffset_SignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_LastSignificantCoeffFlag = bFrameBlock ?
                ctxIdxOffset_BlockCat5_FrameCodedBlock_LastSignificantCoeffFlag :
                ctxIdxOffset_BlockCat5_FieldCodedBlock_LastSignificantCoeffFlag;
            ctxIdxBlockCatOffset_LastSignificantCoeffFlag = ctxIdxBlockCatOffset_LastSignificantCoeffFlag_Table[ctxBlockCat];

            ctxIdxOffset_CoeffAbsLevelMinus1 = ctxIdxOffset_BlockCat5_CoeffAbsLevelMinus1;

            for( levelListIdx = idx_start; levelListIdx < maxNumCoeff; levelListIdx++ )
            {
                ctxIdxInc = bFrameBlock ?
                    ctxIdxInc_BlockCat5913_FrameCodedBlock_SignificantCoeffFlag[levelListIdx] :
                    ctxIdxInc_BlockCat5913_FieldCodedBlock_SignificantCoeffFlag[levelListIdx];

                ctxIdx_SignificantCoeffFlag = ctxIdxOffset_SignificantCoeffFlag + ctxIdxBlockCatOffset_SignificantCoeffFlag + ctxIdxInc;

                ctxIdxInc = ctxIdxInc_BlockCat5913_LastSignificantCoeffFlag[levelListIdx];
                ctxIdx_LastSignificantCoeffFlag = ctxIdxOffset_LastSignificantCoeffFlag + ctxIdxBlockCatOffset_LastSignificantCoeffFlag + ctxIdxInc;

                H264BsFake_EncodeSingleBin_CABAC_8u16s(bs, ctxIdx_SignificantCoeffFlag, pResidualCoeffs[levelListIdx] != 0);

                if (pResidualCoeffs[levelListIdx] != 0)
                {
                    sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];
                    H264BsFake_EncodeSingleBin_CABAC_8u16s(bs, ctxIdx_LastSignificantCoeffFlag, levelListIdx == nLastNonZeroCoeff);

                    if (levelListIdx == nLastNonZeroCoeff)
                        break;
                }
            }

            if (levelListIdx == maxNumCoeff && pResidualCoeffs[levelListIdx] != 0)
                sigCoeff[numSigCoeff++] = pResidualCoeffs[levelListIdx];

            break;
        }
    }

    const Ipp32u* ctx_trans0 = ctx_id_trans0;
    const Ipp32u* ctx_trans1 = ctxBlockCat == BLOCK_CHROMA_DC_LEVELS ? ctx_id_trans13 : ctx_id_trans1;

    Ipp32u ctx_id = 0;
    ctxIdxBlockCatOffset_CoeffAbsLevelMinus1 = ctxIdxBlockCatOffset_CoeffAbsLevelMinus1_Table[ctxBlockCat];

    for (i = numSigCoeff - 1; i >= 0; i--)
    {
        Ipp32s coeff = (Ipp32s)sigCoeff[i];
        Ipp32u sign = coeff >> 31; // sign = coeff > 0 ? 0 : 0xffffffff;
        Ipp32u level = (coeff + (~sign)) ^ sign; // level = abs(coeff) - 1

        if (level)
        {
            Ipp32u ctx = ctxIdxOffset_CoeffAbsLevelMinus1 + ctxIdxBlockCatOffset_CoeffAbsLevelMinus1 + ctx_neq1p1[ctx_id];
            H264BsFake_EncodeSingleBin_CABAC_8u16s(bs, ctx, 1);

            ctx = ctxIdxOffset_CoeffAbsLevelMinus1 + ctxIdxBlockCatOffset_CoeffAbsLevelMinus1 + ctx_ngt1[ctx_id];
            H264BsFake_EncodeExGRepresentedLevels_CABAC_8u16s(bs, ctx, --level);

            ctx_id = ctx_trans1[ctx_id];
        }
        else
        {
            Ipp32u ctx = ctxIdxOffset_CoeffAbsLevelMinus1 + ctxIdxBlockCatOffset_CoeffAbsLevelMinus1 + ctx_neq1p1[ctx_id];
            H264BsFake_EncodeSingleBin_CABAC_8u16s(bs, ctx, 0);
            ctx_id = ctx_trans0 [ctx_id];
        }

        H264BsFake_EncodeBypass_CABAC_8u16s(bs, sign & 1);
    }

    return UMC_OK;
}

void InitIntraContextExtra_H264(
                                  Ipp8u* pExtraState, // after 460th
                                  Ipp32s SliceQPy)
{

    Ipp32s i;

    // See subclause 9.3.1.1 of H.264 standard
    SliceQPy = Clip3( 0, 51, SliceQPy );

    for (i = BASE_MODE_FLAG_OFFSET; i <= BASE_MODE_FLAG_OFFSET + 2; i += 1)
    {
        SetContext_H264(pExtraState + i - 460,
            h264_cabac_M_and_N_for_ctxIdx_1024_1026_intra[i - BASE_MODE_FLAG_OFFSET].m,
            h264_cabac_M_and_N_for_ctxIdx_1024_1026_intra[i - BASE_MODE_FLAG_OFFSET].n,
            SliceQPy);
    }
}

void InitInterContextExtra_H264(
                                  Ipp8u* pExtraState, // after 460th
                                  Ipp32s SliceQPy)
{
    Ipp32s i;

    // See subclause 9.3.1.1 of H.264 standard
    SliceQPy = Clip3( 0, 51, SliceQPy );

    for (i = BASE_MODE_FLAG_OFFSET; i <= BASE_MODE_FLAG_OFFSET + 2; i += 1)
    {
        SetContext_H264(pExtraState + i - 460,
            h264_cabac_M_and_N_for_ctxIdx_1024_1026_inter[i - BASE_MODE_FLAG_OFFSET].m,
            h264_cabac_M_and_N_for_ctxIdx_1024_1026_inter[i - BASE_MODE_FLAG_OFFSET].n,
            SliceQPy);
    }

    for (i = BASE_MODE_FLAG_OFFSET + 3; i <= BASE_MODE_FLAG_OFFSET + 6; i += 1)
    {
        SetContext_H264(pExtraState + i - 460,
            h264_cabac_M_and_N_for_ctxIdx_1027_1030[i - BASE_MODE_FLAG_OFFSET - 3].m,
            h264_cabac_M_and_N_for_ctxIdx_1027_1030[i - BASE_MODE_FLAG_OFFSET - 3].n,
            SliceQPy);
    }
}


#define PIXBITS 8
#include "umc_h264_bs_tmpl.cpp.h"
#define FAKE_BITSTREAM
#include "umc_h264_bs_tmpl.cpp.h"
#undef FAKE_BITSTREAM
#undef PIXBITS

#ifdef BITDEPTH_9_12

#define PIXBITS 16
#include "umc_h264_bs_tmpl.cpp.h"
#define FAKE_BITSTREAM
#include "umc_h264_bs_tmpl.cpp.h"
#undef FAKE_BITSTREAM
#undef PIXBITS

#endif // BITDEPTH_9_12


} //namespace UMC_H264_ENCODER

#endif //MFX_ENABLE_H264_VIDEO_ENCODE

